\section{Performance Advisories}
\label{sec:advisories}

The previous section has shown that miniboxed generics alone provide two key invariants that ensure all primitive values are passed using the miniboxed (long integer) encoding:

\begin{compactitem}
\item Instantiations of miniboxed classes use the most specific variant available (e.g. a value of type |Node[Int]| has runtime class |Node_M|);
\item Methods called on a miniboxed class use the most specific variant available (e.g. a runtime class |Node_M| never receives calls to the erased |head| accessor)
\end{compactitem}

We have also seen that the presence of erasure and wildcard-type abstractions (e.g. |Node[_]|) leads to violations of these two invariants: the erased variant of a miniboxed classes may be instantiated in place of a more specialized variant and the methods called may not always be the most specific ones available. In both cases, the compilation scheme is resiliant, producing correct results, a the expense of performance regressions, caused by boxing primitive types.

There key to avoiding these subtle performance regressions is to intercept the \textem{first instantiation or call} that violates the invariant, which, in turn, may lead to other violations. Luckily, this piece of information is available at compile-time and we can produce actionable warnings based on it.

% A fundamentally difficult problem with using miniboxing is determining when the code has reverted to using boxed primitives. Having miniboxed code use boxed primitives is most commonly caused by interacting with erased generics and specialization, but can also be caused by technical or design limitations. While all these cases lead to correct and semantically-equivalent code, they do produce noticeable slowdowns.

% When boundary conditions or limitations occur in a typical opaque transformation, the optimization process silently fails, and doesn't give the programmer any useful information about what happened. Instead, the miniboxing transformation provides the programmer with a detailed report of the error followed by the common workaround or links to in-depth discussions on the topic. Using this feature, novice programmers can fine-tune their programs without a thorough understanding of the transformation.

\subsection{Performance Advisories Overview}

Advisories are most commonly triggered by interacting with erased or specialized generics, but can also be caused by technical or design limitations. There are as many as 10 different performance advisories implemented in the miniboxing plugin, but in order to focus on the concept, we will only look at the three most common advisories, both caused by the interaction with erased generics. To show exactly how the slowdowns occur, we can take the following piece of code:

\begin{lstlisting-nobreak}
 def foo[`@miniboxed` T](t: T): T = bar(t)
 def bar[`@miniboxed` U](u: U): U = baz(u)
 def baz[`@miniboxed` V](v: V): V = v
\end{lstlisting-nobreak}

The code is transformed to:

\begin{lstlisting-nobreak}
 def foo(t: Object): Object = bar(t)
 def bar(u: Object): Object = baz(u)
 def baz(v: Object): Object = v
 def foo`_M`(..., t: long): long = bar`_M`(..., t)
 def bar`_M`(..., u: long): long = baz`_M`(..., u)
 def baz`_M`(..., v: long): long = v
\end{lstlisting-nobreak}

The translation shows that once execution entered the miniboxed path, by calling |foo_M|, it goes through without any boxing, only passing the value in the encoded (miniboxed) representation. However, let us think of what happens if the |@miniboxed| annotation is removed from method |bar|:

\begin{lstlisting-nobreak}
 def foo[`@miniboxed` T](t: T): T = bar(t)
 def bar[T](u: U): U = baz(u)
 def baz[`@miniboxed` V](v: V): V = v
\end{lstlisting-nobreak}

This produces the following code:

\begin{lstlisting-nobreak}
 def foo(t: Object): Object = bar(t)
 def bar(u: Object): Object = baz(u)
 def baz(v: Object): Object = v
 def foo_M(..., t: long): long = `box2minibox(bar(minibox2box(t)))` // boxing :(
 def baz_M(..., v: long): long = v
\end{lstlisting-nobreak}

Two problems that occur here:

\begin{compactitem}
 \item When method |foo| is called, it does not have a miniboxed version of |bar| to call;
 \item When method |bar| is called, although |baz| has a miniboxed version, it cannot be called as no type information is available.
\end{compactitem}

These two problems correspond exactly to the two of the main of performance advisories: forward and backward. A third one, unspecificity, will be shown below.

\subsubsection{Forward advisories.} The first advisory (compiler warning) received by the programmer is also called a forward warning:

\begin{lstlisting-nobreak-nolang}
test.scala:7: warning: The method bar would benefit from miniboxing type parameter U, since it is instantiated by miniboxed type parameter T of method foo:

       def foo[@miniboxed T](t: T): T = bar(t)
                                        ^
\end{lstlisting-nobreak-nolang}

This advisory pushes the miniboxed representation from caller to callee each time the arguments need to be boxed before being passed.

\subsubsection{Backward advisories.} The miniboxing annotation is also propagated from callee to caller:

\begin{lstlisting-nobreak-nolang}
test.scala:8: warning: The following code could benefit from miniboxing specialization if the type parameter U of method bar would be marked as "@miniboxed U" (it would be used to instantiate miniboxed type parameter V of method baz):

        def bar[U](u: U): U = baz(u)
                                     ^
\end{lstlisting-nobreak-nolang}

\subsubsection{Unspecific advisories.} Scala allows certain types that are neither primitives nor objects. In this category we have wildcard types (existentials in Scala), |Any| and |Nothing|. These types cannot be used to signal either primitive or an object type:

\begin{lstlisting-nobreak-nolang}
test.scala:12: warning: Using the type argument "Any" for the miniboxed type parameter T of method foo is not specific enough, as it could mean either a primitive or a reference type. Although method foo is miniboxed, it won't benefit from specialization:
              foo[Any]("hi")
                   ^
res3: Any = hi
\end{lstlisting-nobreak-nolang}

With these actionable warnings, even a novice programmer, not familiar to the miniboxing transformation, is still capable of achieving the same performance as a specialization expert manually sifting through the many classes generated by the compiler. We have several examples where programmers achieved speedups over 2x just by following the miniboxing advisories \cite{miniboxing-www}.

The next section will discuss the implementation of performance advisories.

\subsection{Unification Intuition}

The reason we chose to present the ``forward'', ``backward'' and ``unspecific'' advisories is because, although they are only three of the ten cases, they are the warnings a typical programmer is most likely to encounter. They apply to almost all cases where a specialized variant of either a method or class needs to be chosen:

\begin{compactitem}
 \item Calling miniboxed methods;
 \item Instantiating miniboxed classes;
 \item Calling method of miniboxed classes;
 \item Extending miniboxed classes or traits;
\end{compactitem}

The one element common to all these cases is the need to pick the best matching miniboxed variant based on a set of type parameters. For example, given the method |foo| defined previously, if we call |foo[Int](4)|, we need to find the |foo_M| variant and redirect the code to it. And, in some cases, either the type parameters of the target or the type arguments are not specific enough. For example, in the call to |foo[Any]("hi")|, the type argument |Any| is not specific enough, resulting in an ``unspecific'' advisory.

Let us now focus on a more formal definition

\subsection{Unification Formalization}

Let us call the original method or class |O|, with the type parameters |F1| to |Fn| and |VO| the set of miniboxed variants corresponding to |O|. Then, each specialized variant |V| corresponds to a mapping from each type parameter to an entry in the set of \{miniboxed, object, erased\}. Let us call the inverse mapping, from the set of type parameter specializations to variants |VS|.

Then the unification examples above can be reduced to choosing the corresponding |V|$\in$|VO|, for a term of type |O[T1, .., Tn]|. This can be done following the algorithm in Figure 1. To make things easier, let us take an example:

\begin{lstlisting-nobreak}
class C[@miniboxed M, N]
class D[L] extends C[L, Int]
\end{lstlisting-nobreak}

When deciding which specialized variant of miniboxed class |C| to use as class |D|'s parent, we have:
\begin{compactitem}
 \item the original class |O| = |C|;
 \item the type parameters |F1| = |M| and |F2| = |N|;
 \item the set of variants |VO| = \{|C_L|,|C_M|\};
 \item the inverse mapping |VS| = \{(|M| miniboxed), (|N| erased) $\rightarrow$ |C_M|, (|M| object), (|N| erased) $\rightarrow$ |C_M|\}
\end{compactitem}

Now, applying the unification algorithm in Figure 1 for the type parameter |F1| = |M| couples with the type argument |T1| = |L|, it issues a forward warning followed by outputting (|M| object). Then, applying it to |F1| = |N| and |T1| = |Int|, it issues a backward warning and outputs (|N| erased). From the two bindings, we obtain the specialized variant |C_L| to be a parent of |D|. Indeed, this is what happens in practice:

\begin{lstlisting-nobreak-nolang}
scala> class C[@miniboxed M, N]
defined class C

scala> class D[L] extends C[L, Int]
<console>:8: warning: The following code could benefit from miniboxing specialization if the type parameter L of class D would be marked as "@miniboxed L" (it would be used to instantiate miniboxed type parameter M of class C):
       class D[L] extends C[L, Int]
             ^
<console>:8: warning: The class C would benefit from miniboxing type parameter N, since it is instantiated by a primitive type:
       class D[L] extends C[L, Int]
             ^
defined class D

scala> classOf[D[_]].getSuperclass
res7: Class[_ >: D[_]] = class C_L
\end{lstlisting-nobreak-nolang}

\begin{figure}[t!]
  \label{fig:algorithm}
  \centering
  \includegraphics[height=0.91\textheight]{../graphs/warnings.pdf}
  \vspace{0.01\textheight}
  \caption{The unification algorithm for picking the state of a type parameter.}
\end{figure}

By now you probably guessed where the names forward and backward warnings came from: the direction in which the miniboxing transformation propagates between the type parameter and the type argument. We will now describe some of the implementation issues.

\subsection{Unification Implementation}

The performance advisories are tightly coupled with the unification algorithm, which decides the variant that should be used for transforming the code. The processing is done one step at a time, with a type parameter and type argument pair. We will now show some issues that an implementer must be careful about.

\subsubsection{Owner chain status.} Since methods and classes in Scala can be nested, we need to be careful to propagate the status of the type parameters in the owner chain. In the following example:

\begin{lstlisting-nobreak}
 def a[@miniboxed A] = {
   def b[@miniboxed B] = {
     // need to be aware of the miniboxed status
     // of type parameter A of method a when
     // deciding which variant of C to instantiate:
     new C[A, B]()
   }
   ...
 }
\end{lstlisting-nobreak}

When deciding which miniboxed variant of class |C| to instantiate, we need to be aware of the where we are located: if we're in method |b_M| inside method |a_M|, we can rely on values of type |A| and |B| to be miniboxed. Contrarily, if we are in method |b| inside method |a|, values of type |A| and |B| are represented as objects.

\subsubsection{Caching warnings.} Instead of issuing warnings right away, they are being cached and later de-duplicated. The reason is that the programmer should not be hit with more than one warning per type parameter, otherwise the value of warnings decreases. Aside from the three advisories shown, there are special advisories dealing with the specialization transformation in Scala and certain library constructs we will analyze in the next section. Thus, we define an ordering of advisory priority and, if multiple warnings are cached, we only issue the most important one.

\subsubsection{Suppressing warnings.} In certain scenarios, programmers are aware of their sub-optimal erased generic code but, due to compatibility requirements with other JVM programs or due to technical limitations, they chose not to change it. In these situations, they need to suppress the warnings, since instead of improving visibility, they prevent a clear picture of the sub-optimalities in the program. However, a coarse-grained approach such as turning off all warnings is not desirable either, since it hides other potentially valuable pieces of information. For this scenario, the miniboxing transformation provides the |@generic| annotation, which can suppress both forward and backward warnings:

\begin{lstlisting-nobreak}
 scala> def zoo[`@miniboxed` T](t: T) = t
 defined method zoo

 scala> zoo[Any `@generic`](3) // no forward warning
 res1: Any = 3

 scala> def boo[`@generic` T](t: T) = t
 defined method boo

 scala> boo[Int](3)                   // no backward warning
 res2: Int = 3
\end{lstlisting-nobreak}


\subsubsection{Libraries.} In other cases boxing is caused by the interaction with erased generics from libraries. In this case, the default decision is not to warn, unless the programmer specifically sets the |-P:minibox:warn-all| compiler flag:

\begin{lstlisting-nobreak}
 scala> 3 :: Nil
 <console>:8: warning: The method List.:: would benefit from miniboxing type parameter B, since it is instantiated by a primitive type:

               3 :: Nil
                 ^
 res0: List[Int] = List(3)
\end{lstlisting-nobreak}

As we will see in the benchmarking section (\S\ref{sec:bench}), the performance advisories allow programmers who are not familiar with the transformation to make the changes an expert in the area would do.

% \subsection{Data Representation Reflection}
%
% This section will show how the miniboxing transformation offers a window into what code is running and how it was transformed. Consider the following two examples:
%
% \begin{compactitem}
% \item Having shut off some of the performance advisories, a programmer may still want to guarantee a class is only instantiated in its specialized form using reflection;
% \item When designing a container, the actions may depend on the types of elements stored: In the immutable |RRB-Vector| \cite{nicolas-thesis} implementation, when elements from the front or back are removed, underlying arrays that store elements can be reused. Here, only starting and stopping indices of the resultant immutable vector are updated. However, if |Vector| is used to store references, reusing previous arrays can result in memory leaks (since the arrays keep a reference to the deleted object for the old vector, but create a reference path between the new vector and the deleted element). In this case, the ideal solution would be to change the behavior of the |Vector| class based on the type argument and only reuse the arrays for primitive types.
% \end{compactitem}
%
% % what is mbreflection
% The |MbReflection| object allows the programmer to check the internal state of the plugin by reflecting on the type parameters of miniboxed classes and methods. For example, given a method with a miniboxed type parameter |T|, reflection can determine, at run-time, whether |T| is miniboxed, its instantiation, and the type used to store the value:
%
% \begin{lstlisting-nobreak}
%  scala> import MiniboxingReflection._
%  import MiniboxingReflection._
%
%  scala> def bip[@miniboxed T] = s"bip[T = ${`reifiedType[T]`}, miniboxed into a ${`storageType[T]`}]"
%  defined method bip
%
%  scala> bip[Int]
%  res4: String = bip[T = Int, miniboxed into a Long]
% \end{lstlisting-nobreak}
%
% The method |reifiedType[T]| indicates the type of type parameter instantiation while the |storageType[T]| returns the type used for encoding data. It is also possible to call the method from an erased context, in which case it will report the fact that the type parameter is a reference to a boxed object:
%
% \begin{lstlisting-nobreak}
%  scala> def bop[T] = bip[T]
%  // backward warning...
%  defined method bop
%
%  scala> bop[Int]
%  // forward warning...
%  res5: String = bip[T = Reference, miniboxed into a Reference]
% \end{lstlisting-nobreak}
%
% From an implementation point of view, the reflection methods are simply bridged after duplication to either constant values (in the case of the |_L| variants of the classes and methods) or to the type byte mentioned in \S\ref{sec:minibox}, for the |_M| variants. This is a simple mechanism which offers programmers yet another way to avoid slow paths in their programs.  Other reflection features include the partial evaluation of reflection method calls when the result is statically known and optimized conversion methods that allow converting values to and from the miniboxed representation efficiently. Instead of presenting these features in detail, we will now focus on the inter-operation between miniboxing and specialized library classes, which exposes a completely different type of slow path.