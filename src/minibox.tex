\section{Compilation Schemes for Generics}
\label{sec:minibox}

This section describes the different compilation schemes for generics in Scala. We mainly use Scala for the examples, but the discussion can be applied to Java as well. Differences between Scala specialization and Project Valhalla are pointed out along the way, with their implications.

\subsection{Erasure in Scala}

% Generics are crucial to productivity. They allow programmers to design algorithms and data structures that operate identically regardless of the data used, fostering code reuse. For example, a |Vector[T]| can be instantiated for any type, whether for numbers, strings or CPU threads. However, on the low level, data comes in different shapes and sizes: from 1-bit booleans to 64-bit long integers, floating point numbers, characters, value classes \cite{gosling-value-classes,rose-value-classes-tearing,sip-value-classes} and objects. In a |Vector[Int]|, getters and setters receive integer values of 32-bits while in |Vector[Double]| they receive 64-bit double-precision floating-point numbers.

The current compilation scheme for generics in both Java and Scala is called erasure, and is the simplest compilation scheme possible for generics. Erasure requires all data, regardless of its type, to be passed in by reference, pointing to heap objects. Let us take a simple example, a generic |identity| method written in Scala:

\begin{lstlisting-nobreak}
 def identity[T](t: T): T = t
 val five = identity(5)
\end{lstlisting-nobreak}

When compiled, the bytecode for the method is\footnote{Throughout the paper, we show the source-equivalent of the bytecode. The context clarifies whether we are showing source code or bytecode.}:

\begin{lstlisting-nobreak}
 def identity(t: `Object`) = `Object`
\end{lstlisting-nobreak}

As the name suggests, the type parameter |T| was ``erased'' from the method, leaving it to accept and return |Object|, |T|'s upper bound. The problem with this approach is that values of primitive types, such as integers, need to be transformed into heap objects when passed to generic code, so they are compatible with |Object|.This process, called boxing goes two ways: the argument of method |identity| needs to be boxed while the return value needs to be unboxed back to a primitive type:

\begin{lstlisting-nobreak}
 val five = identity(`Integer.valueOf(5)`).`intValue()`
\end{lstlisting-nobreak}

Boxing primitive types requires heap allocation and garbage collection, both of which degrade program performance. Furthermore, when values are stored in generic classes, such as |Vector[T]|, they need to be stored in the boxed format, thus inflating the heap memory requirements and slowing down execution. In practice, generic methods can be as much as 10 times slower than their monomorphic (primitive) instantiations. This gave rise to a simple and effective idea: specialization.

\subsection{Specialization}

Specialization \cite{specialization-iuli, iuli-thesis} is a second approach used by the Scala compiler to translate generics and, for methods, is similar to Project Valhalla. It is triggered by the |@specialized| annotation:

\begin{lstlisting-nobreak}
 def identity[`@specialized` T](t: T): T = t
 val five = identity(5)
\end{lstlisting-nobreak}

Based on the annotation, the specialization transformation creates several versions of the |identity| method:

\begin{lstlisting-nobreak}
 def identity(t: Object): Object = t
 def identity`_I`(t: int): int = t
 def identity`_C`(t: char): char = t
 // ... and another 7 versions of the method
\end{lstlisting-nobreak}

Having multiple methods, also called specialized variants or simply specializations of the |identity| method, the compiler can optimize the call to |identity|:

\begin{lstlisting-nobreak}
 val five: int = identity`_I`(5)
\end{lstlisting-nobreak}

This transformation side-steps the need for a heap object allocation, improving the program performance. However, specialization is not without limitations. As we have seen, it creates 10 versions of the method for each type parameter: the erased version plus 9 specializations (Scala has the 8 primitive types in Java and |Unit| primitive type, which corresponds to Java's |void|). And it gets worse: in general, for $N$ specialized type parameters, it creates $10^N$ specialized variants, the Cartesian product covering all combinations.

Lacking Project Valhalla's virtual machine support, Scala specialization generates the specialized variants during compilation and stores them as bytecode. This prevents the Scala library from using specialization extensively, since many important classes have one, two or even three type parameters. This led to the next development, the miniboxing transformation.

\subsection{Miniboxing}

Taking a low level perspective, we can observe the fact that all primitive types in the Scala programming language fit within 64 bits. This is the main idea that motivated the miniboxing transformation \cite{miniboxing}: instead of creating separate versions of the code for each primitive type alone, we can create a single one, which stores 64-bit encoded values, much like a tagged union \cite{tagged-unions-lua}. But unlike a tagged union, miniboxing uses the static type information to avoid carrying tags with each value. The previous example:

\begin{lstlisting-nobreak}
 def identity[`@miniboxed` T](t: T): T = t
 val five = identity(5)
\end{lstlisting-nobreak}

Is compiled\footnote{In the rest of the paper we assume the miniboxing Scala complier plugin is active unless otherwise noted. For more information on adding the miniboxing plugin to the build please see \url{http://scala-miniboxing.org}.} to the following bytecode:

\begin{lstlisting-nobreak}
 def identity(t: Object): Object = t
 def identity`_M`(..., t: long): long = t
 val five: int= `minibox2int`(identity`_M`(`int2minibox`(5)))
\end{lstlisting-nobreak}

Alert readers will notice the |minibox2int| and |int2minibox| transformations act exactly like the boxing coercions in the case of erased generics. This is true: the values are being coerced to the miniboxed representation, much like in the case of erasure. Yet, our benchmarks on the Java Virtual Machine platform have shown that the miniboxing conversion cost is completely eliminated when compiling the code to native 64-bit assembly code. Further benchmarking has shown that the code matches the performance of specialized code within a 10\% slowdown due to coercions \cite{miniboxing}, compared to a 10x slowdown in the case of boxing.

There is an ellipsis in the definition of the |identity_M| method, which stands for what we call a type byte: a byte describing the type encoded in the long integer, allowing operations such as |toString|, |hashCode| or |equals| to be executed correctly on encoded values:

\begin{lstlisting-nobreak}
 def string[`@miniboxed` T](t: T): String = t.toString
\end{lstlisting-nobreak}

In order to transform this method, we need to treat the primitive value as its original type (corresponding to |T|) rather than a long integer. To do so, we use the type byte to differentiate between different primitive types encoded as long:

\begin{lstlisting-nobreak}
 def string(t: Object): String = t.toString
 def string`_M`(T_Tag: byte, t: long): String =
                                        minibox2string(`T_Tag`, t)
\end{lstlisting-nobreak}

Then, when the programmer makes a call to |string|:

\begin{lstlisting-nobreak}
 string[Boolean](true)
\end{lstlisting-nobreak}

It automatically gets transformed in the compiler pipeline to:

\begin{lstlisting-nobreak}
 string`_M`(BOOL, bool2minibox(true))
\end{lstlisting-nobreak}

Knowing the type byte, the |minibox2string| can do its magic: decoding the long integer into a ``true'' or ``false'' string, depending on the encoded value. Although seemingly simple, the code transformation to implement the miniboxing transformation is quite tricky \cite{miniboxing-linkedlist, ldl, ildl-tech}.

So far, we have only looked at methods, but transforming classes poses even greater challenges.

\subsection{Class Transformation in Project Valhalla}

Project Valhalla takes a straight-forward approach to specialization: classes are duplicated and all previous references to the type parameters are transformed. Given the linked list node class:

\begin{lstlisting-nobreak}
 public class Node<T> {
   T head;
   Node<T> tail;

   public Node(T head, Node<T> tail) {
     this.head = head;
     this.tail = tail;
   }

   public T head() {
     return this.head;
   }

   public Node<T> tail() {
     return this.tail;
   }
 }
\end{lstlisting-nobreak}

When there is a need for the |Node| class specialized for |int|, the Project Valhalla transformation uses the classloader support to transform references to |T| into |int|:

\begin{lstlisting-nobreak}
 public class Node_{T=int} { // Node<int> in the syntax
   int head;
   Node_{T=int} tail;

   public Node(int head, Node_{T=int} tail) {
     this.head = head;
     this.tail = tail;
   }

   public int head() {
     return this.head;
   }

   public Node_{T=int} tail() {
     return this.tail;
   }
 }
\end{lstlisting-nobreak}

The effect of this translation is that the only common superclass of |Node| and |Node_{T=int}| is |Object|. Yet, for an erased generic method, such as:

\begin{lstlisting-nobreak}
static <U> U getNodeTail(Node<U> spec) {
  return spec.tail();
}
\end{lstlisting-nobreak}

The generated bytecode is:

\begin{lstlisting-nobreak}
static Object getNodeTail(Node spec) {
  return spec.tail();
}
\end{lstlisting-nobreak}

Therefore, the |getNodeTail| method cannot handle any of the specialized variants of class |Node|, unless it is specialized itself. The same occurs when abstracting using wildcard type: |Node<?>| is erased to |Node| and is not compatible with |Node_{T=int}|. While this transformation has the advantage of simplicity, a slightly more complex transformation can achieve compatibility with erased generics.

\subsection{Class Transformation in Miniboxing}

Scala specialization \cite{iuli-thesis, specialization-iuli} introduced a better class translation, which is compatible to erased generics. Miniboxing \cite{miniboxing} inherited and adapted this scheme, addressing two of its major drawbacks, namely the double fields and broken inheritance. For this reason, we will present the class translation scheme in miniboxing directly.

The main challenge of interoperating with erased generics is to preserve the inheritance relation while providing specialized variants of the class, where fields are encoded as miniboxed long integers instead of |Object|s. Let us take the linked list node class again, this time written in Scala:

\begin{lstlisting-nobreak}
 class Node[`@miniboxed` T](val head:T, val tail:Node[T])
\end{lstlisting-nobreak}

The Scala compiler desugars the class to (some aspects omitted):

\begin{lstlisting-nobreak}
 class Node[`@miniboxed` T](_head: T, _tail: Node[T]) {
   def head: T = this.head                 // getter for _head
   def tail: Node[T] = this.tail // getter for _tail
 }
\end{lstlisting-nobreak}

There are three subtleties in the |Node| translation:
\begin{compactitem}
  \item First, there should be two versions of the class: one where |_head| is miniboxed, called |Node_M| and another one where |_head| is an |Object|, called |Node_L|;
  \item Then, types like |Node[_]|, which corresponds to Java's wildcard |Node<?>| can be instantiated by both classes, so the two need to share a common interface;
  \item Finally, this shared interface has to contain the specialized accessors corresponding to both classes (so both classes should implement all the methods).
\end{compactitem}

Given these constraints, miniboxing compiles |Node| to an interface:

\begin{lstlisting-nobreak}
 interface Node {
   def head(): Object           // erased accessor
   def head_M(...): long // miniboxed acccesor
   def tail: Node[T]
 }
\end{lstlisting-nobreak}

Note that the |tail| method does not have a second version, as it doesn't accept or return primitive values. Then, we have the two specialized variants of class |Node|:

\begin{lstlisting-nobreak}
 class Node_L(_head: `Object`, _tail: Node) impl Node {
   def head(): Object = this._head
   def head_M(...): long = `box2minibox`(..., `head`)
   def tail(): Node[T] = this._tail
 }

 class Node_M(..., _head: `long`, _tail: Node) ... {
   def head(): Object = `minibox2box`(..., `head_M`(...))
   def head_M(...): long = this._head
   def tail(): Node[T] = this._tail
 }
\end{lstlisting-nobreak}

As before, the ellipsis corresponds to the type bytes. With this translation, code that instantiates the |Node| class is automatically transformed to use one of the two variants. For example:

\begin{lstlisting-nobreak}
 new Node[Int](4, null)
\end{lstlisting-nobreak}

Is automatically transformed to:

\begin{lstlisting-nobreak}
 new Node`_M`[Int](`INT`, `int2minibox`(4), null)
\end{lstlisting-nobreak}

And, when |Node| is instantiated with a miniboxed type parameter:

\begin{lstlisting-nobreak}
 def newNode[`@miniboxed` T](t: T) =
   new Node[T](t, null)
\end{lstlisting-nobreak}

The code is translated to:

\begin{lstlisting-nobreak}
 def newNode(t: Object) = new Node`_L`(t, null)
 def newNode`_M`(T_Tag: byte, t: long) =
   new Node`_M`(T_Tag, t, null)
\end{lstlisting-nobreak}

The translation hints at an optimization that can be done: given a value of type |Node[T]| where |T| is either a primitive or known to be miniboxed, the compiler can call |head_M| instead of |head|, skipping a conversion. The following code:

\begin{lstlisting-nobreak}
 val n = new Node[Int](3, null)
 n.head
\end{lstlisting-nobreak}

Gets translated to:

\begin{lstlisting-nobreak}
 val n = new `Node_M`(..., 3, null)
 n.`head_M`(...)
\end{lstlisting-nobreak}

The same occurs when a type parameter is miniboxed:

\begin{lstlisting-nobreak}
 def getFirst[`@miniboxed` T](n: Node[T]) = n.head
\end{lstlisting-nobreak}

This method is translated to:

\begin{lstlisting-nobreak}
 def getFirst(n: Node): Object = n.head
 def getFirst`_M`(T_Tag: byte, n: Node) = n.head`_M`(T_Tag)
\end{lstlisting-nobreak}

At this point, you may be wondering why the |getFirst| method receives a parameter of type |Node| instead of |Node_L|, or, respectively, |Node_M|. The answer is: to interoperate with erased generics.

%This translation scheme, although not the only one, satisfies the three criteria set above.

\subsection{Interoperating with Erased Generics}

So far, we have seen the following two invariants:
\begin{compactitem}
 \item |Node_L| stands for linked lists containing objects, and we call the |head| accessor on it;
 \item |Node_M| stands for linked lists containing primitive types and we call the |head_M| accessor on it.
\end{compactitem}

Unfortunately, interoperating with erased generics violates both invariants. Consider the following method:

\begin{lstlisting-nobreak}
 def newNodeErased[T](head: T) =
   new Node[T](t, null)
\end{lstlisting-nobreak}

During the compilation of this method, using to erased generics, the compiler is forced to make a static (compile-time) choice: Which class to instantiate for the |new Node[T]|?

Since |newNodeErased| can be called with both (boxed) primitives and objects, the only valid choice is |Node_L|, which can handle both cases. Contrarily, |Node_M| can't handle references, since object pointers are not directly accessible in the JVM: % due to garbage collector restrictions:

\begin{lstlisting-nobreak}
 def newNodeErased(head: Object) =
   new `Node_L`(t, null)
\end{lstlisting-nobreak}

This allows the erased generics to invalidate the invariants:

\begin{lstlisting-nobreak}
 val m = newNodeErased[Int](3)
 n.head
\end{lstlisting-nobreak}

Which is translated to:

\begin{lstlisting-nobreak}
 val m = newNodeErased(Integer.valueOf(3))    // Node_L
 n.`head_M`(INT)// implicit assumption: class is Node_M
\end{lstlisting-nobreak}

This way, the call |head_M| occurs on a |Node_L| class. The symmetric case can also occur, calling |head| on a |Node_M| class. And, what is worse, we can end up with a |Node_L| class storing a primitive value, which means it has to be boxed. While the compilation scheme is robust enough to handle the mix-up, the problem is converting data between representations: from boxed to miniboxed and back. This kills performance.
%
%
%  the class accesses the boxed value, transforms it into a miniboxed value and then returns it. This incurs an important overhead compared to calling |head_M| on a |Node_M| class.
%
% ...The opposite case, calling |head| on a |Node_M| class can occur as well, by passing a linked list to a generic method. This shows how the optimistic assumptions used by the miniboxing and specialization transformations are invalidated by erased generics, thus incurring boxing (\S\ref{sec:advisories}). We will later see how even the inter-operation between specialization and miniboxing needs to go through boxing, producing yet another category of slow paths (\S\ref{sec:library}).
%
