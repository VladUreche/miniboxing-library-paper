\section{Introduction}
\label{sec:intro}

% Generics - erasure vs specialization
Generics on the Java platform are compiled using the erasure transformation \cite{java-erasure}, which allows them to be fully backward compatible with pre-generics bytecode. Unfortunately, on the long run, this choice sacrificed performance, since it led to Java primitive types being transformed into heap objects each time they interact with generics. This conversion, known as boxing, compromises the execution performance and increases the heap footprint, forcing Java to lag behind lower-level languages such as C or C++.
% Full discussion: ersure merits, allowing JVM languages to ``erase'' to JVM bytecode

% Project Valhalla - exploring specialization on the JVM
The performance drawbacks of erasure are currently being addressed in Project Valhalla \cite{goetz-specialization, rose-value-classes-tearing, rose-value-classes-vm}, an important undertaking led by the Java platform architects and aimed at providing unboxed generics for Java and other JVM languages. According to Project Valhalla, the updated bytecode format will include the necessary type information to allow load-time class specialization, effectively creating different versions of classes that directly support primitive types. This load-time transformation approach is also employed by the .NET framework \cite{dot-net-generics, dot-net-generics-form} in order to implement generics.


% The current approach is restrictive in that it segregates different specialization translations:
%  - erased code cannot call specialized variants of the code
%  - there is no way to abstract across different specializations
Unlike .NET generics, which are always specialized, the current design of Project Valhalla, as of June 2015, makes it an explicit goal to have specialization as an opt-in transformation. This would allow the ecosystem to evolve smoothly from erased to specialized generics, allowing both erased and specialized classes to work together. However, there are two important limitations in the interaction between erased and specialized generics: (1) erased code cannot handle specialized instances in a generic manner and (2) abstraction over specialized classes is prohibited. This is shown in the following example:

\begin{lstlisting-nobreak}
// class Spec, is specialized by virtue of its type
// parameter T being annotated with "any":
public class Spec<`any` T> {
  String getString() { ... }
}

// method getSpecString, remains erased:
static <U> void getSpecString(Spec<U> spec) {
  return spec.getString();
}

// Disallowed code patterns:
//  - erased code handling a specialized class:
getSpecString(`new Spec<int>()`);
//  - abstracting over a specialized class:
Spec<?> spec = `new Spec<int>()`;
\end{lstlisting-nobreak}

There are good reasons to disallow these patterns, as they can silently introduce performance regressions, but such decisions make the language less uniform and have already been opposed by the community \cite{king-valhalla-email}.

The Scala programming language, which also compiles to JVM bytecode, has had compile-time specialization for 7 years \cite{iuli-thesis, specialization-iuli} and currently has three mechanisms for compiling generics: erasure, specialization and a new arrival, miniboxing \cite{miniboxing}. All three mechanisms collaborate and can be freely mixed in the Scala code:

\begin{lstlisting-nobreak}
// class Mbox is miniboxed by virtue of the type
// parameter annotation (but could be specialized
// as well, using @specialized):
class Mbox[`@miniboxed` T] {
  def getString(): String = ...
}

// method getMboxString is erased:
def getMboxString[U](mbox: Mbox[U]) = mbox.getString()

// Disallowed code patterns:
//  - erased code handling a miniboxed class:
getMboxString(new Mbox<Int>())
//  - abstracting over a miniboxed or specialized class:
val c: C[_] = new
\end{lstlisting-nobreak}

Despite the uniform behavior, Scala does pay a hefty price for being able to freely mix code using the three generics compilation schemes: calls between different compilation schemes require boxing primitive values. The reason is that boxed primitive values are understood by all three transformations. Furthermore, as we will see later in the paper, instantiating a miniboxed (or specialized) class from erased code leads to the erased version being instantiated instead of its miniboxed (or specialized) variants, in turn leading to unexpected performance regressions. We assume this was one of the top reasons that convinced the Project Valhalla architects against allowing erased and specialized generics to work together.

In this paper, we show how we completely eliminate the unexpected slowdowns in the miniboxing transformation and, as a side effect, allow programmers to easily and robustly use miniboxing to speed up their programs. The underlying property we are after is that, inside hot loops and performance-sensitive parts of the program, all generic code uses the same compilation scheme, in this case, miniboxing. This way, primitive types are always passed using the same data representation, whether that's the miniboxed encoding (for miniboxing) or the unboxed representation (for specialization).

We show two approaches for harmonizing the compilation scheme across performance-sensitive code:

\textbf{Issuing actionable performance advisories} when compilation schemes do not match, allowing the programmer to harmonize them. For example, when a generic method takes a miniboxed class as a parameter and tries to call methods on it, we automatically generate performance advisories:

\begin{lstlisting-nobreak}
scala> def getMboxString[U](mbox: Mbox[U]) =
     |   mbox.getString()
<console>:9: warning: The following code could benefit
from miniboxing if the type parameter U of method
getMboxString would be marked as "@miniboxed U":
         mbox.getString()
             ^
\end{lstlisting-nobreak}

Another problem that occurs frequently concerns library evolution: as a new compilation schemes arrives, it is best if all libraries start using it as soon as possible. However, backward compatibility prohibits changing the compilation scheme for the standard library, as it would break old bytecode. In Scala, we had this problem because many of the core language constructs, such as functions and tuples use specialization instead of miniboxing. Similarly, Java has as many as 20 manual specializations for the arity 1 lambda, such as |IntConsumer|, |IntPredicate| and so on. Replacing these by a single specialized functional interface would be desirable, but is realistically impossible. However, there is a solution to this.

\textbf{Offering equivalents of the standard library classes} for the new compilation scheme. In the case of miniboxing, which is a compiler plugin, we were not able to change the standard library functions or tuples to the miniboxing compilation scheme. However, we describe a number of approaches that can solve the problem, both manual and automatic.

With this, the paper is making four key contributions to the Java community and, in the general sense, to the field of compiling object-oriented languages with generics:

\begin{compactitem}
  \item Describing the problems involved in mixing different generics compilation schemes (\S\ref{sec:minibox});
  \item Describing a general mechanism for harmonizing the compilation scheme (\S\ref{sec:advisories});
  \item Describing four approaches we used for offering fast-path communication between objects that use different generic compilation schemes (\S\ref{sec:library});
  \item Validating the approach using the miniboxing plugin (\S\ref{sec:bench}).
\end{compactitem}

The evaluation section (\S\ref{sec:bench}) shows that warnings not only help avoid performance regressions, but can also guide the programmer into further improving the program performance.