\section{Introduction}
\label{sec:intro}

% Most optimizations => compromises => heuristics => opaque to programmers => hinders productivity

% Productiviy => high-level abstractions => redundant operations
Productivity in modern software development is achieved using high-level languages that allow programmers to focus on the requirements and the problem domain. The high-level programs are then compiled to low-level implementations that, when executed, produce the desired result. However, the translation is often too defensive: in checked languages, for example, accessing an array twice using the same index produces two array bounds checks, even though the second one is clearly redundant.

% Productivity => optimizations (to close performance gap)
With programming languages targeting higher and higher abstraction levels, program optimizations are becoming an essential component of compilers. Due to the nature of translating high-level abstractions, the low level code contains redundant operations, which slow down execution. To improve this, optimization passes eliminate or shortcut redundant operations, bridging the performance gap between abstractions and their low-level, hand-coded equivalents.

% Program optimizations are compromises.
While some optimizations can be guaranteed to produce better results (e.g. eliminating redundant bounds checks), others tend to be compromises. For example, many opportunistic transformations, such as shape analysis, split the program into two paths: a fast path, where the opportunistic shape assumptions are satisfied and the program is optimized and a slow path, which has to execute slower and more general operations. This makes opportunistic transformations a compromise: they can either speed up a section of the program or slow it down, since taking the slow path usually requires additional data transformations.

% Ultimately, heuristics hinder productivity.
While opportunistic optimizations are a great tool to have in a compiler's toolbox, they are very difficult for the programmers to reason about: these transformations use opaque heuristics and can easily be invalidated by adding new code additions or introducing a new type of data. Therefore, programmers treat these optimizations as black boxes and rely on benchmarks to reverse-engineer when and how the code is optimized. Ultimately, this undoes the benefits of high-level programming, by saving time on the program conception but wasting it on benchmarking.

% Show how an opaque transformation => transparent
The first part of our paper explains how we offer programmers a window into the inner workings of an opportunistic transformation, namely the miniboxing specialization scheme for generics. Miniboxing offers performance advisories, in the form of compile-time warnings explaining where suboptimal code occurred and how to prevent it. A highlight of our approach is its ability to teach the programmers what they need to do to maximize performance: only based on the advisories, we were able to speed up a program by 4x, without the programmer even knowing what how the miniboxing transformation works.

% Another example of slow/fast path => interoperating with foreign objects/APIs (ex: JNI)
Another example of slow/fast paths occurs when inter-operating with foreign objects or external code, which do not have the same data representation and guarantees as the optimized code. For example, when invoking JNI (Java Native Interface) calls in a class, many of the standard Java Virtual Machine (JVM) optimizations do not kick in anymore, since these optimizations may prevent the external code from running correctly.

% Miniboxing => API
In the case of the miniboxing transformation, which transforms the way data is represented, inter-operating with foreign objects forces a slow path, as data needs to be converted to the foreign object's desired representation and back to the miniboxed encoding. As we will see later, this incurs significant performance losses. Unfortunately, inter-operating with foreign objects cannot be banned, even more when the foreign objects consist of the target language's standard library, which is compiled with an incompatible scheme.

The second part of the paper focuses on translating hostile objects exposed by the language to miniboxing-friendly objects, thus avoiding the slow path during execution. For example, we look at the function representation, which is hostile to the miniboxing encoding, requiring heap objects to be allocated even for a task as elementary as invoking the function for a set of arguments. The solutions proposed are discussed in-depth and the approaches can be reused in other scenarios as well.


\topic{Contributions.}
% Contributions
%  - describe the mechanisms we used to offer transparency
%  - explain how we dealt with existing suboptimal API
%  - benchmark our changes and show how, combined, the sum of the parts is greater than each individual part.

% Conclusion
\topic{Conclusion.}



% Improving The Programmer Experience
%  - Performance Advisories
%  - Exposing internal state - MbReflection
% Bridging Existing Abstractions to Optimized Implementations
%  - Function => MbFunction
%  - Tuple    => accessors + constructors
% Exposing New Optimized Abstractions
%  - MbArray
% Benchmarks
%  - Performance Advisories => 5x improvement
%  - MbFunction
%  - MbArray => MbArray + MbFunction
%  - MbTuple => need benchmark
% Related Work