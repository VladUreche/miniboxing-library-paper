

\section{Benchmarks}
\label{sec:bench}

In the benchmarks section, we show four different scenarios where miniboxing has significantly improved performance of user programs. Although we present the benchmark resuts in the paper, the individual experiments have been done independently and should not be considered a contribution. Instead, we name the person who performed each benchmark, the venue where it was published or described. We specifically steer away from mentioning benchmarking methodology, as each experiment was run on a different machine and with a different benchmarking platform (Google Caliper \cite{google-caliper}, JMH \cite{jmh} and ScalaMeter \cite{scalameter}).

\subsubsection{Performance advisories} can be used to improve the performance of Scala programs without any previous knowledge of how the transformation works. This was shown at the PNWScala 2014 software development conference \cite{pnwscala-conf}, where Vlad Ureche presented how the miniboxing plugin guides the programmer into improving the performance of a mock-up of a image processing library by as much as 4x \cite{pnwscala-pureimage}. The presentation was recorded and the performance numbers are included in Table \ref{table:pureimage} for reference.


\begin{table}[t]
  \begin{tabularx}{0.48\textwidth}{|g *{3}{|Y}|} \hline
    \rowcolor{Gray}
    \textbf{Benchmark} & \textbf{Generic} & \textbf{Miniboxed}& \textbf{Miniboxed} \\
    \rowcolor{Gray}
                       &                  &                   & +functions \\ \hline
    Sum              &              100.6 ms &              355.9 ms &             12.0 ms \\
    SumOfSquares     &              188.3 ms &              450.9 ms &             13.0 ms \\
    SumOfSqEven      &              130.8 ms &              300.4 ms &             52.2 ms \\
    Cart             &              220.6 ms &              560.2 ms &             55.3 ms \\ \hline
  \end{tabularx}
  \vspace{-2mm}
  \caption{Scala Streams pipelines for 10M elements.}
  \label{table:streams}
  \vspace{-1em}
\end{table}

% normal exec:
% [info] Benchmark                                       Mode  Samples        Score  Score error  Units
% [info] r.VecMapBenchmark.squareDoubleArrayWithLoop    thrpt       20  1532951.740    10201.172  ops/s
% [info] r.VecMapBenchmark.squareDoubleArrayWithMap     thrpt       20    74578.832      644.821  ops/s
% [info] r.VecMapBenchmark.squareDoubleVec              thrpt       20  1418579.315    10376.822  ops/s
% with -P:minibox:library-functions
% [info] Benchmark                                       Mode  Samples        Score  Score error  Units
% [info] r.VecMapBenchmark.squareDoubleArrayWithLoop    thrpt       20  1540313.539    18644.313  ops/s
% [info] r.VecMapBenchmark.squareDoubleArrayWithMap     thrpt       20    89519.549      760.324  ops/s
% [info] r.VecMapBenchmark.squareDoubleVec              thrpt       20   324700.925     3609.481  ops/s
\begin{table}[b]
  \begin{tabularx}{0.48\textwidth}{|g *{1}{|Y}|} \hline
    \rowcolor{Gray}
    \textbf{Benchmark}             &  \textbf{Running time} \\ \hline
    Manual C-like code             &         0.650 $\mu$s \\
    Miniboxing with functions      &         0.705 $\mu$s \\
    Miniboxing without functions   &         3.080 $\mu$s \\
    Miniboxing without arrays      &         6.832 $\mu$s \\
    Generic                        &        13.409 $\mu$s \\ \hline
  \end{tabularx}
  \vspace{-2mm}
  \caption{Mapping a 1K Framian vector.}
  \label{table:framian}
  \vspace{-1em}
\end{table}

\subsubsection{Tuple accessors} have been tested by Milos Stojanovic by implementing a quicksort-based tuple sorting benchmark \cite{tuple-bench}, which sorts tuples based on their first element. The algorithm used is quicksort and the result shows a 2x speed improvement when the accessors are used. The performance is also on par with both specialized and monomorphic code, the slowdown being at most 5\%. The results are shown in Table \ref{table:tuple}.

\subsubsection{Miniboxed functions} have been used in many cases, one of the most demanding being the Scala Streams library developed by Aggelos Biboudis. This library, similar in spirit to the Java8 streams has been implemented and tested in \cite{biboudis_clash_2014}. Table \ref{table:streams} shows the impact of replacing the function encoding from the Scala |FunctionX| to the miniboxed |MbFunctionX|. Furthermore, the Streams library exercises many of the slowdown paths, passing miniboxed functions to generic code and back, stress-testing the conversions between the two representations.

\subsubsection{The Framian Vector implementation} is an exploration into deeply specializing the immutable |Vector| bulk storage performed by Tom Switzer for the Framian library \cite{framian}. Since vectors normally rely on arrays, they are expected to carry |ClassTag| objects around. However, this exploration tried to make the Vector work equally well without using reified types \cite{tixxit-respecialization15,tixxit-respecialization6}. This is a benchmark that stresses both the function transformation and the miniboxed array implementation (|MbArrays|). Table \ref{table:framian} shows a 4.4x speed improvement when the function representation is optimized.
