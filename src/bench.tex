

\section{Benchmarks}
\label{sec:bench}

In the benchmarks section, we show four different scenarios where miniboxing has significantly improved performance of user programs. Although we present the benchmark resuts in the paper, the individual experiments have been done independently and should not be considered a contribution. Instead, we name the person who performed each benchmark, the venue where it was published or described. We specifically steer away from mentioning benchmarking methodology, as each experiment was run on a different machine and with a different benchmarking platform (Google Caliper \cite{google-caliper}, JMH \cite{jmh} and ScalaMeter \cite{scalameter}).

\subsubsection{Performance advisories} can be used to improve the performance of Scala programs without any previous knowledge of how the transformation works. This was shown at the PNWScala 2014 software development conference \cite{pnwscala-conf}, where Vlad Ureche presented how the miniboxing plugin guides the programmer into improving the performance of a mock-up of a image processing library by as much as 4x \cite{pnwscala-pureimage}. The presentation was recorded and the performance numbers are included in Table \ref{table:pureimage} for reference.

\subsubsection{The RRB-Vector} data structure \cite{rrb-vector-paper} \cite{nicolas-thesis} is an improvement over the immutable |Vector|, allowing it to perform well for data parallel operations. Currently, the immutable |Vector| collection in the Scala library offers very good asymptotic performance over a wide range of sequential operations, but fails to scale well for data parallel operations. The problem is the overhead of merging the partial results obtained in parallel, due to the rigid Radix-Balanced Tree, the |Vector|'s underlying structure. Contrarily, |RRB-Vector| uses Relaxed Radix-Balanced (RRB) Trees, which allow merges to occur in effectively constant time while preserving the sequential operation performance. This enables the |RRB-Vector| to scale up as we would expect when executing data parallel operations. Thanks to the parallel improvement, the |RRB-Vector| data structure is slated to replace the |Vector| implementation in the Scala library in a future release. 

Implementation of |RRB-Vector| uses erased generics as a translation for generics and in this benchmark we will show how by following the performance advisories given by Miniboxing plugin we can change it to miniboxing translation and improve performance of its operations. Firstly, only methods wich are needed for operations used in benchmarks are kept \cite{rrb-vector-miniboxed-impl} and all unused parts of the implementation were removed. Then, the code is compiled with the Miniboxing plugin which gave to the user 28 distinct warnings. Warnings adviced the user where to add |@miniboxed| annotation and where to use |MbArray| instead of |Array| so the implementation can benefit from miniboxing transformation. By following the suggested advices given by compiler, in 3 steps and less than 30 minutes of work, programmer who is not the author of |RRB-Vector| and not familiar with the code, managed to improve the performances of some |RRB-Vector| operations by 50\%. 

Operations used for benchmarking the miniboxed and generic variants of |RRB-Vector| implementation are creating the |RRB-Vector| using |RRBVectorBuilder| and invoking |map|, |fold| and |reverse| operations on |RRB-Vector|. ScalaMeter framework \cite{scalameter} is used as a benchmark platform and the measurements are conducted using JDK 1.7 on the machine with processor Intel Core i7-4600U CPU @ 2.10GHz x 4 and with RAM of 12GiB. Results of the benchmark are included in Table \ref{table:rrbvector}. 

The numbers show that for |builder|, |map| and |fold| tests there is a speedup of at least 2x when miniboxing transformation is used which is expected as both boxing and unboxing of the value parameters are present there. On the other hand, |reverse| operation does not require any boxing and therefore there is no any speedup achieved. However, numbers from |reverse| test show that miniboxing does not introduce any noticeable slowdowns as well. To conclude, by following the advises given by miniboxing plugin, the user who does not have any familiarity with the code, for relatively short period of time (if we consider the time needed for development of the |RRB-Vector| which was approximately 4 months and that implementation has \textasciitilde3K LOC) can improve the performance of some operations by 50\%.

\begin{table}[t]
  \centering
  \begin{tabularx}{0.48\textwidth}{|g *{3}{|Y}|} \hline
    \rowcolor{Gray}
    \textbf{Benchmark} & \textbf{Generic}      & \textbf{Miniboxed} \\  \hline
    Builder            &        161.61 s       &           53.56 s  \\
    Map                &         98.43 s       &           49.38 s  \\
    Fold               &         87.98 s       &           46.14 s  \\
    Reverse            &         27.97 s       &           33.84 s  \\  \hline
  \end{tabularx}
  \vspace{-2mm}
  \caption{RRB-Vector operations for 5M elements.}
  \label{table:pureimage}
  \vspace{-1em}
\end{table}


\begin{table}[t]
  \begin{tabularx}{0.48\textwidth}{|g *{3}{|Y}|} \hline
    \rowcolor{Gray}
    \textbf{Benchmark} & \textbf{Generic} & \textbf{Miniboxed}& \textbf{Miniboxed} \\
    \rowcolor{Gray}
                       &                  &                   & +functions \\ \hline
    Sum              &              100.6 ms &              355.9 ms &             12.0 ms \\
    SumOfSquares     &              188.3 ms &              450.9 ms &             13.0 ms \\
    SumOfSqEven      &              130.8 ms &              300.4 ms &             52.2 ms \\
    Cart             &              220.6 ms &              560.2 ms &             55.3 ms \\ \hline
  \end{tabularx}
  \vspace{-2mm}
  \caption{Scala Streams pipelines for 10M elements.}
  \label{table:streams}
  \vspace{-1em}
\end{table}

% normal exec:
% [info] Benchmark                                       Mode  Samples        Score  Score error  Units
% [info] r.VecMapBenchmark.squareDoubleArrayWithLoop    thrpt       20  1532951.740    10201.172  ops/s
% [info] r.VecMapBenchmark.squareDoubleArrayWithMap     thrpt       20    74578.832      644.821  ops/s
% [info] r.VecMapBenchmark.squareDoubleVec              thrpt       20  1418579.315    10376.822  ops/s
% with -P:minibox:library-functions
% [info] Benchmark                                       Mode  Samples        Score  Score error  Units
% [info] r.VecMapBenchmark.squareDoubleArrayWithLoop    thrpt       20  1540313.539    18644.313  ops/s
% [info] r.VecMapBenchmark.squareDoubleArrayWithMap     thrpt       20    89519.549      760.324  ops/s
% [info] r.VecMapBenchmark.squareDoubleVec              thrpt       20   324700.925     3609.481  ops/s
\begin{table}[b]
  \begin{tabularx}{0.48\textwidth}{|g *{1}{|Y}|} \hline
    \rowcolor{Gray}
    \textbf{Benchmark}             &  \textbf{Running time} \\ \hline
    Manual C-like code             &         0.650 $\mu$s \\
    Miniboxing with functions      &         0.705 $\mu$s \\
    Miniboxing without functions   &         3.080 $\mu$s \\
    Miniboxing without arrays      &         6.832 $\mu$s \\
    Generic                        &        13.409 $\mu$s \\ \hline
  \end{tabularx}
  \vspace{-2mm}
  \caption{Mapping a 1K Framian vector.}
  \label{table:framian}
  \vspace{-1em}
\end{table}

\subsubsection{Tuple accessors} have been tested by Milos Stojanovic by implementing a quicksort-based tuple sorting benchmark \cite{tuple-bench}, which sorts tuples based on their first element. The algorithm used is quicksort and the result shows a 2x speed improvement when the accessors are used. The performance is also on par with both specialized and monomorphic code, the slowdown being at most 5\%. The results are shown in Table \ref{table:tuple}.

\subsubsection{Miniboxed functions} have been used in many cases, one of the most demanding being the Scala Streams library developed by Aggelos Biboudis. This library, similar in spirit to the Java8 streams has been implemented and tested in \cite{biboudis_clash_2014}. Table \ref{table:streams} shows the impact of replacing the function encoding from the Scala |FunctionX| to the miniboxed |MbFunctionX|. Furthermore, the Streams library exercises many of the slowdown paths, passing miniboxed functions to generic code and back, stress-testing the conversions between the two representations.

\subsubsection{The Framian Vector implementation} is an exploration into deeply specializing the immutable |Vector| bulk storage performed by Tom Switzer for the Framian library \cite{framian}. Since vectors normally rely on arrays, they are expected to carry |ClassTag| objects around. However, this exploration tried to make the Vector work equally well without using reified types \cite{tixxit-respecialization15,tixxit-respecialization6}. This is a benchmark that stresses both the function transformation and the miniboxed array implementation (|MbArrays|). Table \ref{table:framian} shows a 4.4x speed improvement when the function representation is optimized.
