\begin{table}[t]
  \centering
  \begin{tabularx}{0.48\textwidth}{|g *{3}{|Y}|} \hline
    \rowcolor{Gray}
    \textbf{Benchmark} & \textbf{Generic}      & \textbf{Miniboxed} \\  \hline
    Builder            &        161.61 s       &           53.56 s  \\
    Map                &         98.43 s       &           49.38 s  \\
    Fold               &         87.98 s       &           46.14 s  \\
    Reverse            &         27.97 s       &           33.84 s  \\  \hline
  \end{tabularx}
  \vspace{-2mm}
  \caption{RRB-Vector operations for 5M elements.}
  \label{table:rrbvector}
  \vspace{-1em}
\end{table}

\begin{table}[b]
  \centering
  \begin{tabularx}{0.48\textwidth}{|g *{3}{|Y}|} \hline
    \rowcolor{Gray}
    \textbf{Benchmark} & \textbf{Generic}      & \textbf{Miniboxed}     & \textbf{Miniboxed} \\
    \rowcolor{Gray}    &                       &  some                  &  all               \\
    \rowcolor{Gray}    &                       &  advisories            &  advisories        \\
    \rowcolor{Gray}    &                       &  heeded                &  heeded            \\ \hline
    1st run            &               4192 ms &               3082 ms &             1346 ms \\
    2nd run            &               4957 ms &               2998 ms &             1187 ms \\
    3rd run            &               4755 ms &               3017 ms &             1178 ms \\
    4th run            &               3969 ms &               2535 ms &             1094 ms \\
    5th run            &               4073 ms &               2615 ms &             1163 ms \\ \hline
  \end{tabularx}
  \vspace{-2mm}
  \caption{Speedups based on performance advisories, PNWScala}
  \label{table:pureimage}
  \vspace{-1em}
\end{table}

\section{Benchmarks}
\label{sec:bench}

In this section we show three different scenarios where miniboxing has significantly improved performance of user programs. We will specifically avoid mentioning benchmarking methodology, as each of the experiments was ran on a different setup. Yet, all three examples show a clear trend: using the techniques shown improve both performance and the programmer experience.

\subsubsection{The RRB-Vector} data structure \cite{rrb-vector-paper} \cite{nicolas-thesis} is an improvement over the immutable |Vector|, allowing it to perform well for data parallel operations. Currently, the immutable |Vector| collection in the Scala library offers very good asymptotic performance over a wide range of sequential operations, but fails to scale well for data parallel operations. The problem is the overhead of merging the partial results obtained in parallel, due to the rigid Radix-Balanced Tree, the |Vector|'s underlying structure. Contrarily, |RRB-Vector| uses Relaxed Radix-Balanced (RRB) Trees, which allow merges to occur in effectively constant time while preserving the sequential operation performance. This enables the |RRB-Vector| to scale up as we would expect when executing data parallel operations. Thanks to the parallel improvement, the |RRB-Vector| data structure is slated to replace the |Vector| implementation in the Scala library in a future release.

Implementation of |RRB-Vector| uses erased generics as a translation for generics and in this benchmark we will show how by following the performance advisories given by Miniboxing plugin we can change it to miniboxing translation and improve performance of its operations. Firstly, only methods which are needed for operations used in benchmarks are kept \cite{rrb-vector-miniboxed-impl} and all unused parts of the implementation were removed. Then, the code is compiled with the Miniboxing plugin which gave to the user 28 distinct warnings. Warnings advised the user where to add |@miniboxed| annotation and where to use |MbArray| instead of |Array| so the implementation can benefit from miniboxing transformation. By following the suggested advice given by compiler, in 3 steps and less than 30 minutes of work, programmer who is not the author of |RRB-Vector| and not familiar with the code, managed to improve the performances of some |RRB-Vector| operations by 50\%.

\begin{table}[t]
  \begin{tabularx}{0.48\textwidth}{|g *{1}{|Y}|} \hline
    \rowcolor{Gray}
    \textbf{Transformation} & \textbf{Running time}  \\ \hline
    Monomorphic             &              318.1 ms  \\
    Specialized             &              322.5 ms  \\
    Miniboxed + Tuples      &              323.2 ms  \\
    Miniboxed               &              726.8 ms  \\
    Generic                 &              684.4 ms  \\ \hline
  \end{tabularx}
  \vspace{-2mm}
  \caption{Sorting 1M tuples using quicksort.}
  \label{table:tuple}
  \vspace{-3em}
\end{table}


Operations used for benchmarking the miniboxed and generic variants of |RRB-Vector| implementation are creating the |RRB-Vector| using |RRBVectorBuilder| and invoking |map|, |fold| and |reverse| operations on |RRB-Vector|. ScalaMeter framework \cite{scalameter} is used as a benchmark platform and the measurements are conducted using JDK 1.7 on the machine with processor Intel Core i7-4600U CPU @ 2.10GHz x 4 and with RAM of 12GiB. Results of the benchmark are included in Table \ref{table:rrbvector}.

The numbers show that for |builder|, |map| and |fold| tests there is a speedup of at least 2x when miniboxing transformation is used which is expected as both boxing and unboxing of the value parameters are present there. On the other hand, |reverse| operation does not require any boxing and therefore there is no any speedup achieved. However, numbers from |reverse| test show that miniboxing does not introduce any noticeable slowdowns as well. To conclude, by following the advises given by miniboxing plugin, the user who does not have any familiarity with the code, for relatively short period of time (if we consider the time needed for development of the |RRB-Vector| which was approximately 4 months and that implementation has \textasciitilde3K LOC) can improve the performance of some operations by 50\%.




%1st step: 14 warnings + 5 MbArray warnings = 19 total -> 8 @miniboxed added and 5 new Array changed to MbArray.empty
%2nd step: 9 warnings + 1 Numeric warning + 1 MbArray = 11 total -> 8 @miniboxed, 1 MbNumeric instead of Numeric
%3rd: 5 warnings-> 4 @miniboxed
%4: 4 warnings -> 2 @miniboxed
%5: 1 warning -> 1 @miniboxed
%6: 0 warnings -> 0 @miniboxed

%7: display0 to MbArray
%8: 1 warning -> 1 @miniboxed
%9: 1 warning -> 1 @miniboxed





\subsubsection{Performance advisories} can be used to improve the performance of Scala programs without any previous knowledge of how the transformation works. This was shown at the PNWScala 2014 developer conference \cite{pnwscala-conf}, where Vlad Ureche presented how the miniboxing plugin guides the programmer into improving the performance of a mock-up of a image processing library by as much as 4x \cite{pnwscala-pureimage}. The presentation was recorded and the performance numbers are included in Table \ref{table:pureimage} for reference.

\subsubsection{Tuple accessors} have been tested by Milos Stojanovic by implementing a quicksort-based tuple sorting benchmark \cite{tuple-bench}, which sorts tuples based on their first element. The algorithm used is quicksort and the result shows a 2x speed improvement when the accessors are used. The performance is also on par with both specialized and monomorphic code, the slowdown being at most 5\%. The results are shown in Table \ref{table:tuple}.

