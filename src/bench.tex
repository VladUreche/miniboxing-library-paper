

\section{Benchmarks}
\label{sec:bench}

% In the benchmarks section, we show four different scenarios where miniboxing has significantly improved performance of user programs. Although we present the benchmark results in the paper, the individual experiments have been done independently and should not be considered a contribution. Instead, we name the person who performed each benchmark, the venue where it was published or described. We specifically steer away from mentioning benchmarking methodology, as each experiment was run on a different machine and with a different benchmarking platform (Google Caliper \cite{google-caliper}, JMH \cite{jmh} and ScalaMeter \cite{scalameter}).
%
% \subsubsection{Performance advisories} can be used to improve the performance of Scala programs without any previous knowledge of how the transformation works. This was shown at the PNWScala 2014 software development conference \cite{pnwscala-conf}, where Vlad Ureche presented how the miniboxing plugin guides the programmer into improving the performance of a mock-up of a image processing library by as much as 4x \cite{pnwscala-pureimage}. The presentation was recorded and the performance numbers are included in Table \ref{table:pureimage} for reference.

\subsubsection{The RRB-Vector} data structure \cite{rrb-vector-paper} \cite{nicolas-thesis} is an improvement over the immutable |Vector|, allowing it to perform well for data parallel operations. Currently, the immutable |Vector| collection in the Scala library offers very good asymptotic performance over a wide range of sequential operations, but fails to scale well for data parallel operations. The problem is the overhead of merging the partial results obtained in parallel, due to the rigid Radix-Balanced Tree, the |Vector|'s underlying structure. Contrarily, |RRB-Vector| uses Relaxed Radix-Balanced (RRB) Trees, which allow merges to occur in effectively constant time while preserving the sequential operation performance. This enables the |RRB-Vector| to scale up as we would expect when executing data parallel operations. Thanks to the parallel improvement, the |RRB-Vector| data structure is slated to replace the |Vector| implementation in the Scala library in a future release.

Implementation of |RRB-Vector| uses erased generics as a translation for generics and in this benchmark we will show how by following the performance advisories given by Miniboxing plugin we can change it to miniboxing translation and improve performance of its operations. Firstly, only methods wich are needed for operations used in benchmarks are kept \cite{rrb-vector-miniboxed-impl} and all unused parts of the implementation were removed. Then, the code is compiled with the Miniboxing plugin which gave to the user 28 distinct warnings. Warnings adviced the user where to add |@miniboxed| annotation and where to use |MbArray| instead of |Array| so the implementation can benefit from miniboxing transformation. By following the suggested advices given by compiler, in 3 steps and less than 30 minutes of work, programmer who is not the author of |RRB-Vector| and not familiar with the code, managed to improve the performances of some |RRB-Vector| operations by 50\%.

Operations used for benchmarking the miniboxed and generic variants of |RRB-Vector| implementation are creating the |RRB-Vector| using |RRBVectorBuilder| and invoking |map|, |fold| and |reverse| operations on |RRB-Vector|. ScalaMeter framework \cite{scalameter} is used as a benchmark platform and the measurements are conducted using JDK 1.7 on the machine with processor Intel Core i7-4600U CPU @ 2.10GHz x 4 and with RAM of 12GiB. Results of the benchmark are included in Table \ref{table:rrbvector}.

The numbers show that for |builder|, |map| and |fold| tests there is a speedup of at least 2x when miniboxing transformation is used which is expected as both boxing and unboxing of the value parameters are present there. On the other hand, |reverse| operation does not require any boxing and therefore there is no any speedup achieved. However, numbers from |reverse| test show that miniboxing does not introduce any noticeable slowdowns as well. To conclude, by following the advises given by miniboxing plugin, the user who does not have any familiarity with the code, for relatively short period of time (if we consider the time needed for development of the |RRB-Vector| which was approximately 4 months and that implementation has \textasciitilde3K LOC) can improve the performance of some operations by 50\%.

\begin{table}[t]
  \centering
  \begin{tabularx}{0.48\textwidth}{|g *{3}{|Y}|} \hline
    \rowcolor{Gray}
    \textbf{Benchmark} & \textbf{Generic}      & \textbf{Miniboxed} \\  \hline
    Builder            &        161.61 s       &           53.56 s  \\
    Map                &         98.43 s       &           49.38 s  \\
    Fold               &         87.98 s       &           46.14 s  \\
    Reverse            &         27.97 s       &           33.84 s  \\  \hline
  \end{tabularx}
  \vspace{-2mm}
  \caption{RRB-Vector operations for 5M elements.}
  \label{table:pureimage}
  \vspace{-1em}
\end{table}
