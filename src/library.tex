\section{Functions and Tuples}
\label{sec:library}

% Section - library + miniboxing => boxing, how to avoid it, example
In this section we will show how slow paths occur when miniboxed code interacts with the Scala standard library, which uses either erased generics or the original specialization transformation, which generates 10 variants per type parameter. We show three approaches to avoiding the slow path and show how each of them fits with the library entities.

% The problem
When interacting with the library from miniboxed code, the programmers are aware functions and tuples are specialized, so they expect to have automatic and flawless performance when using them. However, calling specialized code from miniboxed code and vice-versa is not trivial:

\begin{lstlisting-nobreak}
 def mbox[@miniboxed T](t: T): String = spec(t)
 def spec[@specialized T](t: T): String = t.toString
\end{lstlisting-nobreak}

The translated low-level code is:

\begin{lstlisting-nobreak}
 def mbox(t: Object): String = `spec(t)`
 def mbox`_J`(T_Type: byte, t: long): String = `???`
 def spec(t: Object): String = t.toString
 def spec`_I`(t: int): String = Integer(t).toString
 def spec`_J`(t: long): String = Long(t).toString
 ... // other 7 specialized variants
\end{lstlisting-nobreak}

The generic |mbox| method calls |spec|, since there is a 1 to 1 correspondence between them. This is not the case for |mbox_J| and the nine specializations of method |spec|. And while it may seem like |mbox_J| could directly invoke |spec_J|, since the argument type matches, this would be incorrect, as |t| in |mbox_J| can be any primitive type, including boolean, whereas |spec_J| would treat the encoding as a long integer (thus, instead of returning the string ``true'' or ``false'', it would return the encoded value of the boolean).

The |mbox_J| method is in possession of one more piece of information: |T_Type|, the type byte describing the encoded primitive type. In order to call the correct specialized method, |mbox_J| could switch on the type byte and perform the correct conversion:

\begin{lstlisting-nobreak}
 def mbox`_J`(T_Type: byte, t: long): String =
   T_Type match {
     case INT => spec_I(minibox2int(t))
     case LONG => spec_J(minibox2long(t))
     ...
   }
\end{lstlisting-nobreak}

Although this approach seems to work, it takes a step back on the transparency scale: the miniboxing transformation would be introducing extra work without offering the programmer any feedback on how and why this happened. Furthermore, multiple type bytes may be involved in the switch, generating a combinatorial explosion which is likely to confuse the Java Virtual Machine heuristics for inlining, leading to sudden (and difficult to debug) slow paths.

It may seem like the other way around would be much easier, allowing specialized code to call miniboxed code without performing a switch. However this is not the case since the specialization transformation is not aware of miniboxing. Therefore, when calling miniboxed methods, specialization resorts to invoking the generic version, boxing the arguments and unboxing the returned value.

With these aspects in mind, our decision was to go with simplicity and symmetry: both miniboxing and specialization go through boxing when calling each other's transformed code. To allow transparency, miniboxing issues performance advisories about specialized code that should be miniboxed:

\begin{lstlisting-nobreak}
 def mbox`_J`(T_Type: byte, t: long): String =
   // performance advisory: forward warning
   spec(minibox2box(T_Type, t))
\end{lstlisting-nobreak}

This solution works well with most of the code that lies within the programmer's control, including for the case where 3rd party libraries distribute either a specialized or a miniboxed version. However, the one library which cannot have multiple versions and happens to use specialization is the Scala standard library:

\begin{lstlisting-nobreak}
 def tupleMap[@miniboxed T, @miniboxed U](tup: (T, T), f: T => U): (U, U) =
   (f(tup._1), f(tup._2))
\end{lstlisting-nobreak}

Despite the miniboxing annotations, all versions of the |tupleMap| method use the erased generic versions of the tuple acessors and the function application, leading to slow paths irreversibly creeping into miniboxed code. For many applications, this is a no-go, so our task was to eliminate these cases. In the following subsection we present three possible approaches and show where each works best.

\subsection{Eliminating Inter-operation Overhead}

We now discuss three approaches to eliminating the boxing overhead when calling specialized code from miniboxed classes and/or methods.

% Accessors
\subsubsection{Accessors.} The simplest answer to the problem of inter-operating with specialization is to switch on the type byte, as shown above. To avoid confusing the Java Virtual Machine inlining heuristics, we can extract the operation into a static method, that we call separately. This approach needs to be implemented both for accessors, allowing the specialized values to be extracted directly into the miniboxed encoding and for constructors, allowing miniboxed code to instantiate specialized classes without boxing. This is the approach taken for |Tuples|.

% Wrapping objects
\subsubsection{Wrapping objects.} The accessors approach allows us to pay a small (but non-zero) overhead with each access, which is a good tradeoff when the values accessed are only accessed a couple of times during the lifetime of the object. In other cases, such as functions, the |apply| method is expected to be called many times during the object lifetime, making the overhead of the |apply| method undesirable. In this case, another approach is to introduce a wrapper object, in this case |MiniboxedFunction| which exposes a miniboxed |apply| method and does not need to switch on the type byte in order to call the wrapped function: the switch is done when wrapping the function and is a one-time cost, which then amortizes over many function applications.

% New API
\subsubsection{New API.} In some cases, the API and guarantees are hardcoded into the compiler. This is the case for the Scala |Array| class, for which the miniboxing plugin chose the Accessors approach \cite{miniboxing}. However, several limitations of Scala arrays can be eliminated by defining a new |MbArray| class. This approach will be discussed in detail in the Arrays subsection (\S\ref{sec:arrays}).

The next section discusses three Scala library classes for which the miniboxing plugin uses the approaches above.

\subsection{Tuples}

% Challenge => custom syntax + automatic desugaring => we want to keep that
The Scala programming language offers a very concise and pleasant syntax for library tuples, allowing users to write |(3,5)| instead of the desugared |new Tuple2[Int, Int](3,5)|. Similarily, it allows programmers to write |(Int, Int)| instead of |Tuple2[Int, Int]|. If we were to introduce miniboxed tuples, we would not be able to use the syntactic sugar to express programs, losing the support of many programmers. Instead, we're looking into ways to access specialized tuples efficiently, without boxing values.

% acess patterns => a few accesses during the lifetime => accessors
Although we haven't measured rigorously, our experience suggests that |Tuple| classes are usually created just to have their components accessed a few times during their life. Therefore, both for compatibility reasons and to avoid costly conversions, we decided to allow the |Tuple| class to remain unchanged, instead focusing on providing accessors and constructors to provide compatibility.
% Results
Our measurements show that we obtain a 2x speedup using the accessors approach and we are within 5\% of the specialized (and monomorphic) code for a larger tuple quicksort benchmark.

\subsection{Functions}

% Challenge => automatic desugaring + specialization

% New API => desugaring by hand

% Accessors => pay each time

% Wrapping objects, coercions and LDL

% Optimizations
