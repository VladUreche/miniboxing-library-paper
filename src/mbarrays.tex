\section{MbArrays}
\label{sec:mbarrays}

% Arrays = Efficient bulk storage => The underlying container for many collections.

Arrays are one of the oldest data structures that have been used in programs as they provide efficient memory usage and constant random access times that are optimal from a low level perspective for computer architectures of today, one of the reasons being that it cooperates well with caches thanks to the spatial locality of the elements. For these reasons, they constitue the pedestal of many more high level collections, and more generally are the container of choice for implementations of algorithms where performance is critical. Since by definition elements of an array are stored contiguously in memory, their sizes must be known at compile time in order for the compiler to generate the right instructions for array allocation or element retrieval. For example, assuming an integer is encoded on 4 bytes, a compiler will know that the $n^th$ element of an array of integers which first element is stored at the adress $a$ can be accessed by dereferencing the address $a + 4*n$.

% Challenge : Abstraction <=> An Array[T] class that offers performances and versatility : 
% no ClassTag or other ways that involve having to set restrictions on the type parameter or having to modify pre-existing code in order to adjust itself to the use of this new array abstraction : 
%	- If one day we want to use Array[T : ClassTag] instead of SomeCollection[T] => need to modify a lot of code because ClassTags need to be propagated => Breaks the pre-existing code.
%	- If one day we want to use MbArray[T] instead of SomeCollection[T] => The pre-existing code will still work.

Unfortunately, while it offers optimal performances and memory usage, it also hardens significantly the task of abstracting over the type of elements that the array contains. Indeed, different types of elements will yield in different sizes for the elements, and thus the compiler will need to generate different instructions for array access depending on the size of the elements the array contains. In practice, such abstractions are necessary for writing softwares in a productive manner, and therefore different workarounds have been found. For example, we can cite the template-based way, which is used by languages like C++, but in this paper we're interested in how languages based on the JVM and more specifically the Scala programming language deal with this problem, and how we can improve the current way of doing it. 

% Problem 1 : Accessing arrays of a generic type in scala is inefficient (big switch on the runtime type of the array)



% Partial Solution (Optimization) : Assume that array of primitive types are using the optimized JVM arrays : Array[Int] is int[], Array[Double] is double[] etc.

% But this optimization prevents instantiation of arrays in a generic context, because we cannot know at compile time which of int[], double[], Object[], etc we need to allocate.

% Option 1 : Using a ClassTag for the type parameter can give us this info at runtime.

% Problem 2 : ClassTags are expensive to : 
% 	- Synthesize (need to ask about this)
% 	- Propagate (show an example of code)
% 	- Store.
% 		=>  people tend to avoid them.

% Option 2 : Always allocate Object[] (Array[AnyRef]) and use .asInstanceOf[Array[T]] on the object array to make the user believe.

% Problem 3 : This breaks the invariant Array[X] => x[] when X is a primitive. (show example of code that makes the JVM crash)
% 	=> The array must not escape, but this can be hard to guarantee.

% Problem 4 : This is bad for performances, because primitives will need to be boxed in order to fit in the Object[] array.

% Option 3 : Miniboxing. If we are in a miniboxed context we can solve problem 4 by adding two other options on top of Array[AnyRef] : 
% 	- Array[Long] if T is an integral type
% 	- Array[Double] if T is a floating-point type
% But problem 3 still not solved.
% => MbArrays. Solves 3 by wrapping the array in a class that we control and we know won't let the underlying array escape.