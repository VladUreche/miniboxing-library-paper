\section{MbArrays}
\label{sec:mbarrays}

% Arrays = Efficient bulk storage => The underlying container for many collections.
Arrays provide efficient memory usage and constant random access time, thanks to the elements being stored in a contiguous fashion. This is also optimal from a low level perspective as it cooperates well with processor caches, thanks to the spatial locality of the elements. For these reasons, arrays are commonly used as the underlying storage in high level collections, and are the container of choice for implementing performance-critical algorithms.

Since elements of an array are stored contiguously in memory, accessing an element requires knowing its size: assuming an integer is encoded on 4 bytes, a compiler will know that the $n^\text{th}$ element of an integer array stored at the address $a$ can be accessed by de-referencing the address $a + 4*n$. Or, in the case of a higher-level virtual machine, such as the JVM, to avoid tying the implementation to architecture details, each primitive array, such as |int[]| or |double[]| has its own bytecodes to access and update elements, which de-reference the correct address for the given architecture.

% Challenge : Abstraction <=> An Array[T] class that offers performances and versatility :
% no ClassTag or other ways that involve having to set restrictions on the type parameter or having to modify pre-existing code in order to adjust itself to the use of this new array abstraction :
%	- If one day we want to use Array[T : ClassTag] instead of SomeCollection[T] => need to modify a lot of code because ClassTags need to be propagated => Breaks the pre-existing code.
%	- If one day we want to use MbArray[T] instead of SomeCollection[T] => The pre-existing code will still work.

Unfortunately, while using primitive arrays offers optimal performance and memory usage, it also makes it difficult to abstract over the type of elements in the array: different types of elements have different sizes so the compiler needs to generate different instructions for array access depending on its element type. In practice, abstracting over the elements in arrays is essential for writing generic data structures, so language developers proposed different approaches to enable abstraction. One example is the template-based way, used in C++ and .NET, where generics are instantiated to primitive types, resolving their size before execution. On the other hand, languages where generics are compiled with erasure, such as Scala, lose the information necessary to resolve the object size at runtime and need to employ more complex mechanisms.

% Problem 1 : Accessing arrays of a generic type in scala is inefficient (big switch on the runtime type of the array)
A naive solution, commonly used in dynamic language interpreters which lack static information, is to convert all values stored in the array to object references, through boxing. This fixes the size of objects, since only references are stored in the array regardless of the primitive type. However, compact storage and locality are lost, since boxed primitives contain the additional object headers and can be allocated anywhere on the heap.

A much better approach transforms the Scala code that accesses or updates generic arrays:

\begin{lstlisting-nobreak}
 def first[T](a: Array[T]): T = a(0)
\end{lstlisting-nobreak}

The equivalent Scala source code for the low-level bytecode generated by the Scala compiler is:

\begin{lstlisting-nobreak}
 def first(a: Object): Any =
   a match {
     case x: Array[Object] => x(0) // size = reference
     case x: Array[Int]           => x(0) // size = integer
     case x: Array[Double] => x(0) // size = double
     // and so on for all the primitive types of Scala
   }
\end{lstlisting-nobreak}


% Partial Solution (Optimization) : Assume that array of primitive types are using the optimized JVM arrays : Array[Int] is int[], Array[Double] is double[] etc.
With this transformation, accessing the array becomes more involved: the program has to match over the possible primitive arrays, and only then it can access the element. This slows down program execution, but it also enforces a strong invariant: a Scala value of type |Array[Int]| is always represented as the JVM primitive integer array, |int[]|, and never as |Array[java.lang.Integer]|, which would require boxing the primitive values. This invariant guarantees that, outside the generic context, array access/update is efficient: an |Array[Int]| is represented as the JVM primitive |int[]| array, which allows Scala to access and update elements without matching its type. Therefore, from a language perspective, programmers only pay the extra overhead when using arrays with generics.

Another thing to notice is that the |Array[T]| type in the signature of |first| is transformed into |Object|: at the JVM level, primitive arrays such as |int[]|, |float[]| and |Object[]| have a single common parent class, which is |java.lang.Object|. This explains why there is a need to match the primitive array type: the |Array| class offered by Scala does not really exist, it's simply an abstraction over the primitive arrays offered by the JVM.

\vlad{I didn't go through the rest:}

% But this optimization prevents instantiation of arrays in a generic context, because we cannot know at compile time which of int[], double[], Object[], etc we need to allocate.

Now that we have shown why transformations such as the one above were necessary, we will present another problem introduced by this representation of primitive type arrays, namely, generic array instantiation. In this case, it is not possible to instantiate the optimized version of primitive type arrays in a generic context, because this would require having informations about the type parameter at runtime, which is not inherently possible due to the type erasure process performed by compilers that compile for the JVM.

% Option 1 : Using a ClassTag for the type parameter can give us this info at runtime.

To address this issue, Scala offers the |ClassTag| mechanism, which can be used to provide informations at runtime about a type parameter. Although it started from a good idea, it is often not used in practice because they come up with a cost that developpers are not necessarily prone to pay. Indeed, |ClassTags| are expensive to:

% Problem 2 : ClassTags are expensive to :
% 	- Synthesize (need to ask about this)
% 	- Propagate (show an example of code)
% 	- Store.
% 		=>  people tend to avoid them.

\begin{itemize}
  \item Synthesize.
  \item Propagate.
  \item Store.
\end{itemize}

To illustrate these items, consider the following code :

\begin{lstlisting-nobreak}
  def foo[T] = bar[T]
  def bar[T] = baz[T]
  def baz[T] = new SomeCollection[T](10)
\end{lstlisting-nobreak}

Suppose we want to start using a generic |Array| instead of |SomeCollection|. We will replace

\begin{lstlisting-nobreak}
  new SomeCollection[T](10)
\end{lstlisting-nobreak}

by

\begin{lstlisting-nobreak}
  new Array[T : `ClassTag`](10)
\end{lstlisting-nobreak}

But for a |ClassTag| to be available in the |baz| function, it must have been available at the site |baz| was called, that is, in |bar|, and so on. The code presented above would have to be written this way:

\begin{lstlisting-nobreak}
  def foo[T: `ClassTag`] = bar[T]
  def bar[T: `ClassTag`] = baz[T]
  def baz[T: `ClassTag`] = new SomeCollection[T](10)
\end{lstlisting-nobreak}

As one can see, this creates the need to propagate the |ClassTag| from the bottom -- therefore breaking pre-existing code -- and to store it in the stack each time one of the function is called, introducing runtime overhead affecting memory and performances. On top of that, a |ClassTag| describing the type parameter has to be synthesized at each site a generic class is instantiated, thus producing many anonymous classes polluting the bytecode and even more overhead when the generic class is instanciated at runtime.

% Option 2 : Always allocate Object[] (Array[AnyRef]) and use .asInstanceOf[Array[T]] on the object array to make the user believe.
% Problem 3 : This breaks the invariant Array[X] => x[] when X is a primitive. (show example of code that makes the JVM crash)
% 	=> The array must not escape, but this can be hard to guarantee.

Another way to deal with this issue is to always instantiate |Array[AnyRef]| and make the compiler believe it is actually an |Array[T]| by using |asInstanceOf[Array[T]]| on the array. As one could imagine, this has some major drawbacks. One of them being that it breaks the invariant stated earlier which says that an |Array[Int]| must be seen by the compiler as |int[]|, and equivalently for the other primitive type arrays. In our case, |Array[Int]| would actually be an |Array[AnyRef]|. Therefore, accessing an element of the array will make the JVM crash. We could fix this by guaranteeing that the array will not escape from what is under our control, which cannot be done trivially.

% Problem 4 : This is bad for performances, because primitives will need to be boxed in order to fit in the Object[] array.

The other downside of this way of doing is that it will restrain performance when dealing with arrays of primitive types, as the primitive values will have to be boxed in order to fit in an |Array[AnyRef]|, therefore bringing it back to the problems stated earlier.

% Option 3 : Miniboxing. If we are in a miniboxed context we can solve problem 4 by adding two other options on top of Array[AnyRef] :
% 	- Array[Long] if T is an integral type
% 	- Array[Double] if T is a floating-point type
% But problem 3 still not solved.
% => MbArrays. Solves 3 by wrapping the array in a class that we control and we know won't let the underlying array escape.