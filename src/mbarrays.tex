\section{MbArrays}
\label{sec:mbarrays}

% Arrays = Efficient bulk storage => The underlying container for many collections.

Arrays are one of the oldest data structures that have been used in programs as they provide efficient memory usage and constant random access times that are optimal from a low level perspective for computer architectures of today, one of the reasons being that it cooperates well with caches thanks to the spatial locality of the elements. For these reasons, they constitue the pedestal of many more high level collections, and more generally are the container of choice for implementations of algorithms where performance is critical. Since by definition elements of an array are stored contiguously in memory, their sizes must be known at compile time in order for the compiler to generate the right instructions for array allocation or element retrieval. For example, assuming an integer is encoded on 4 bytes, a compiler will know that the $n^th$ element of an array of integers which first element is stored at the adress $a$ can be accessed by dereferencing the address $a + 4*n$.

% Challenge : Abstraction <=> An Array[T] class that offers performances and versatility : 
% no ClassTag or other ways that involve having to set restrictions on the type parameter or having to modify pre-existing code in order to adjust itself to the use of this new array abstraction : 
%	- If one day we want to use Array[T : ClassTag] instead of SomeCollection[T] => need to modify a lot of code because ClassTags need to be propagated => Breaks the pre-existing code.
%	- If one day we want to use MbArray[T] instead of SomeCollection[T] => The pre-existing code will still work.

Unfortunately, while it offers optimal performances and memory usage, it also hardens significantly the task of abstracting over the type of elements that the array contains. Indeed, different types of elements will yield in different sizes for the elements, and thus the compiler will need to generate different instructions for array access depending on the size of the elements the array contains. In practice, such abstractions are necessary for writing softwares in a productive manner, and therefore different workarounds have been found. For example, we can cite the template-based way, which is used by languages like C++, but in this paper we're interested in how languages based on the JVM and more specifically the Scala programming language deal with this problem, and how we can improve the current way of doing it. 

% Problem 1 : Accessing arrays of a generic type in scala is inefficient (big switch on the runtime type of the array)

Before tackling the next topic, assume the following Scala code.

\begin{lstlisting-nobreak}
  def retrieve[T](a: Array[T], i: Int): T = {
    a(i)
  }
\end{lstlisting-nobreak}

The bytecode that is generated by the Scala compiler for the code above is equivalent to what would be generated for the code below : 

\begin{lstlisting-nobreak}
  def retrieve(a: AnyRef, i: Int): Any = {
    a match {
      case x: Array[AnyRef] => x(i).asInstanceOf[Any]
      case x: Array[Int] => x(i).asInstanceOf[Any]
      case x: Array[Double] => x(i).asInstanceOf[Any]
      // and so on for the 10 primitives types of Scala...
    }
  }
\end{lstlisting-nobreak}

As one can see, the generated code is suboptimal, because each generic array access results in a long and costly match over the type of the array, which do affect runtime performances badly.  

% Partial Solution (Optimization) : Assume that array of primitive types are using the optimized JVM arrays : Array[Int] is int[], Array[Double] is double[] etc.

In order to understand the reason for such transformation, it is necessary to understand how Scala uses the optimized JVM versions of primitive type arrays when dealing with Scala arrays of primitive types. That is, the Scala compiler will assume that the actual runtime type of an $Array[Int]$ will not be $Array[java.lang.Integer]$ -- as it would require boxing the primitive values and therefore break spatial locality -- but its unboxed variant $int[]$, which itself does present the advantages mentionned earlier such as spatial locality of the datas and for which the JVM knows specific bytecode instructions that are optimized for this specific type of array. This raises the problem observed above, as the different primitive type arrays such as $int[]$ or $float[]$ are different objects that require their own specific instructions for element accesses. Therefore, the only way to execute the right instructions for retrieving an element off of a generic array is to switch over the type of this array.

% But this optimization prevents instantiation of arrays in a generic context, because we cannot know at compile time which of int[], double[], Object[], etc we need to allocate.

Now that we have shown why transformations such as the one above were necessary, we will present another problem introduced by this representation of primitive type arrays, namely, generic array instantiation. In this case, it is not possible to instantiate the optimized version of primitive type arrays in a generic context, because this would require having informations about the type parameter at runtime, which is not inherently possible due to the type erasure process performed by compilers that compile for the JVM. 

% Option 1 : Using a ClassTag for the type parameter can give us this info at runtime.

To address this issue, Scala offers the $ClassTag$ mechanism, which can be used to provide informations at runtime about a type parameter. Although it started from a good idea, it is often not used in practice because they come up with a cost that developpers are not necessarily prone to pay. Indeed, $ClassTags$ are expensive to:

% Problem 2 : ClassTags are expensive to : 
% 	- Synthesize (need to ask about this)
% 	- Propagate (show an example of code)
% 	- Store.
% 		=>  people tend to avoid them.

\begin{itemize}
  \item Synthesize.
  \item Propagate.
  \item Store.
\end{itemize}

To illustrate these items, consider the following code : 

\begin{lstlisting-nobreak}
  def foo[T] = bar[T]
  def bar[T] = baz[T]
  def baz[T] = new SomeCollection[T](10)
\end{lstlisting-nobreak}

Suppose we want to start using a generic $Array$ instead of $SomeCollection$. We will replace
 
\begin{lstlisting-nobreak} 
  new SomeCollection[T](10) 
\end{lstlisting-nobreak}
 
by
 
\begin{lstlisting-nobreak} 
  new Array[T : `ClassTag`](10) 
\end{lstlisting-nobreak}

But for a $ClassTag$ to be available in the $baz$ function, it must have been available at the site $baz$ was called, that is, in $bar$, and so on. The code presented above would have to be written this way:
 
\begin{lstlisting-nobreak}
  def foo[T: `ClassTag`] = bar[T]
  def bar[T: `ClassTag`] = baz[T]
  def baz[T: `ClassTag`] = new SomeCollection[T](10)
\end{lstlisting-nobreak}

As one can see, this creates the need to propagate the $ClassTag$ from the bottom -- therefore breaking pre-existing code -- and to store it in the stack each time one of the function is called, introducing runtime overhead affecting memory and performances. On top of that, a $ClassTag$ describing the type parameter has to be synthesized at each site a generic class is instantiated, thus producing many anonymous classes polluting the bytecode and even more overhead when the generic class is instanciated at runtime.  

% Option 2 : Always allocate Object[] (Array[AnyRef]) and use .asInstanceOf[Array[T]] on the object array to make the user believe.

% Problem 3 : This breaks the invariant Array[X] => x[] when X is a primitive. (show example of code that makes the JVM crash)
% 	=> The array must not escape, but this can be hard to guarantee.

% Problem 4 : This is bad for performances, because primitives will need to be boxed in order to fit in the Object[] array.

% Option 3 : Miniboxing. If we are in a miniboxed context we can solve problem 4 by adding two other options on top of Array[AnyRef] : 
% 	- Array[Long] if T is an integral type
% 	- Array[Double] if T is a floating-point type
% But problem 3 still not solved.
% => MbArrays. Solves 3 by wrapping the array in a class that we control and we know won't let the underlying array escape.