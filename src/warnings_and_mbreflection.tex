\section{Improving The Programmer Experience}
\label{sec:advisories}
\paragraph{}
In this section, we will discuss how to improve programmer experience by giving them compile-time performance advisories and exposing internal state at run-time. First, we will present the need for performance advisories and introduce the different types of advisories that exist today. A discussion about the motivation for introducing the MbReflection API will follow, along with examples to demonstrate its functionality.
\subsection{Performance Advisories}
\paragraph{}
%what are the performance advisories and what is their purpose
% 2 problems:
%	- programmer not aware of possible optimizations in the code
%	- programmer not aware of limitations of optimizer
% Silent failure - using performance advisories this is avoided
% Shown in form of compile-time warnings
% Improve code performance up to 5 times
A fundamentally difficult problem with using specialization is determining when the code has reverted to using boxed primitives. Having specialized code use boxed primitives can be due to technical or design limitations, which can lead to seemingly correct compilation of the code, but sub-optimal. These limitations can occur at different levels, from well-understood design decisions that sacrifice certain code patterns, to purely technical limitations where the problem is simply not worth the effort to solve.
\paragraph{}
When limitations are reached, the optimization process silently fails, which doesn't give the user any useful information about what happened. Instead of silently failing, specialization can provide the user with possible workarounds and explanations about the optimization failure. This is exactly the function of performance advisories in the Miniboxing plugin. They aim to provide the user with useful compile-time warnings that explain why code could not be fully optimized by specializing generics and detail how the code can be improved in order to achieve the best performance.
\paragraph{}
Besides limitations of the optimizer, it is also possible for the code to be written in a manner that does not fully utilize compiler's optimization potential. Performance advisories of Minibox plugin will assist the programmer in this situation by exposing code where the plugin wasn't able to correctly specialize generics, pointing out exactly what the problem was and suggesting ways to fix it. Introduced performance advisories play an important role by helping improve the performance of a program significantly. Benchmarks show that applying the compilers suggested changes can improve overall performance by up to 4x.
\paragraph{}
%2 types of them - backward and forward
% On the high level - two types of warnings saying that code is not optimal
%	- backwards => at the use site optimizer realizes that code can be optimized by adding annotation at the definition site, by going backward in the code
%	- forward => from the definition site, checks if code is optimized on the use site
At a high level, there are two types of sub-optimal code warnings, backward and forward; both try to tell a user when code can be optimized to gain better performance. Backwards warnings refer to those that can identify when code can be optimized at the use site, and go back and suggest adding the appropriate annotation at the definition site. The examples below illustrate this:

\begin{lstlisting-nobreak}
scala> def foo[X](x: X) = x
foo: [X](x: X): X

scala> foo[Int](3)
<console>:9: warning: The method foo would benefit from miniboxing type
parameter X, since it is instantiated by a primitive type.
              foo[Int](3)
                 ^
res0: Int = 3

scala> def bar[@miniboxed X](x: X) = foo[X](x)
<console>:8: warning: The method foo would benefit from miniboxing type
parameter X, since it is instantiated by miniboxed type parameter X of method bar.
       def bar[@miniboxed X](x: X) = foo[X](x)
                               ^
bar: [X](x: X)X
\end{lstlisting-nobreak}
In the first example, method |foo| is invoked with primitive type parameter |Int|. Boxing can be avoided in this case, but the type parameter |X| in |foo|'s definition has not been annotated for miniboxing. Therefore, this code is sub-optimal and user will be alerted to this fact. In the second example, |foo| is invoked with miniboxed type parameter, but since the parameter |X| in |foo|'s definition was not annotated for miniboxing, the boxed type will be used. In both cases, as the warnings suggest, the solution is to minibox the type parameter |X| of method |foo| as follows:

\begin{lstlisting-nobreak}
scala> def foo[@miniboxed X](x: X) = x
foo: [X](x: X)X

scala> foo[Int](3)
res1: Int = 3

scala> def bar[@miniboxed X](x: X) = foo[X](x)
bar: [X](x: X)X
\end{lstlisting-nobreak}
Forward warnings, on the other hand, check that properly miniboxed type parameters at the definition site are optimized correctly at the use site as well. The following example illustrates this behavior:

\begin{lstlisting-nobreak}
scala> def foo[@miniboxed X](x: X) = x
foo: [X](x: X)X

scala> def bar[X](x: X) = foo[X](x)
<console>:8: warning: The following code could benefit from miniboxing specialization if the type parameter X of method bar would be marked as "@miniboxed X" (it would be used to instantiate miniboxed type parameter X of method foo)
       def bar[X](x: X) = foo[X](x)
                             ^
bar: [X](x: X)X
\end{lstlisting-nobreak}
In the above example, type parameter |X| of method |foo| is miniboxed. \romain{`However` instead of `Anyways`?} Anyways, type parameter |X| of method |bar| is not annotated as miniboxed \romain{I would have added an implication, like `and therefore`} and invoking the method |foo| would not benefit from miniboxing if |X| is \romain{isn't it `one of ` instead of `some of` ?} some of the primitive types. \romain{I think this sounds better `A warning will inform the user that annotating type parameter X in the definition of Bar could make it benefit from miniboxing`} Warning will suggest to user to annotate type parameter |X| in the definition of method |bar| and this way benefit from miniboxing:

\begin{lstlisting-nobreak}
scala> def foo[@miniboxed X](x: X) = x
foo: [X](x: X)X

scala> def bar[@miniboxed X](x: X) = foo[X](x)
bar: [X](x: X)X
\end{lstlisting-nobreak}
\paragraph{}

%\romain{I didn't understand the following paragraph. You say that the warning can show up `when the type parameter of a method is miniboxed but method is invoked with type argument |Any|`, but in your code example the problem seem to be that the miniboxing plugin has problems specializing constructors. Are the two related ? }
\romain{The double negation (`does not allow an unambiguous`) made it hard to understand for me. What about `Besides the warnings shown in the above examples, there is also a warning which can show up when the instantiated type argument could refer to either a primitive type or a reference type`}
Besides the warnings shown in above examples, there is also a warning which shows when the type arguments do not allow an unambiguous choice between primitives and references. This can happen when the type parameter of a method is miniboxed but method is invoked with type argument |Any|. Since |Any| can refer to either a reference type or a primitive type, it is not specific enough to benefit from miniboxing, despite the original definition being miniboxed. \romain{Shouldn't what follows be in another paragraph ? (At first, I thought the code example below was refering to the problem of ambiguous type arguments, which made no sense.)} As mentioned above, miniboxing specialization can have its limitations and the following example shows a warning explaining that the code is sub-optimal due to technical limitations and provides a suitable workaround:

\begin{lstlisting-nobreak}
scala> class W[@miniboxed Z](z: Z) { println(z) }

<console>:7: warning: The following constructor statement will not be
specialized in the miniboxed trait W. This is a technical limitation
that can be worked around: (please see
https://github.com/miniboxing/miniboxing-plugin/issues/64)
       class W[@miniboxed Z](z: Z) { println(z) }
                                            ^
<console>:7: error: The following code is accessing field z of miniboxed
class/trait W, a pattern which becomes invalid after the miniboxing
transformation. Please allow Scala to generate accessors by using val/var
or removing the "private[this]" qualifier: val z: Z".
       class W[@miniboxed Z](z: Z) { println(z) }
                                             ^
defined class W
\end{lstlisting-nobreak}
Finally, in some cases specialization is lost because a class or method in the library was not miniboxed. One example is using collections with primitive types:

\begin{lstlisting-nobreak}
scala> 3 :: Nil
<console>:8: warning: The method scala.collection.immutable.List.::
would benefit from miniboxing type parameter B, since it is
instantiated by a primitive type.
              3 :: Nil
                ^
res0: List[Int] = List(3)
\end{lstlisting-nobreak}

\paragraph{}
%@generic annotation and suppressing warnings
% Programmer may be aware of his suboptimal code and warnings are not needed in that case
% Turning off all the warnings is too coarse-grained
% Possibility to suppress warnings from both the definition-site or the use-site site by adding @generic annotation for type param
% Example + explanation
In certain situations, it is possible for the user to be aware of their sub-optimal code and not want to modify it; in these situations, they should be able to suppress the warnings. However, only allowing the user to suppress all warnings is too coarse, and finer-grained control over which warnings are suppressed should be provided to the user. The Miniboxing plugin offers this by allowing user to add a |@generic| annotation for type parameters. By adding this annotation, all warnings related to that specific type parameter on both definition-site and the use-site would be suppressed. The following example illustrates how this feature can be used:

\begin{lstlisting-nobreak}
scala> def foo[@miniboxed T](t: T) = t
defined method foo
\end{lstlisting-nobreak}
Without |@generic| annotation:

\begin{lstlisting-nobreak}
scala> foo[Any](3)
<console>:9: warning: Using the type argument "Any" for the miniboxed type parameter T of method foo is not specific enough, as it could mean either a primitive or a reference type. Although method foo is miniboxed, it won't benefit from specialization:
              foo[Any](3)
                 ^
res0: Any = 3
\end{lstlisting-nobreak}
With |@generic| annotation:

\begin{lstlisting-nobreak}
scala> foo[Any @generic](3) = 3
res1: Any = 3
\end{lstlisting-nobreak}

\subsection{Exposing internal state - MbReflection}
\paragraph{}
% motivation - define different run time behavior based on class type argument
Performance advisories provide the user with compile-time warnings when code is sub-optimal, and as mentioned above, there is a mechanism to suppress them. However, it is possible that a user want to silence the warnings but still enforce strictness and define a separate run-time behavior for the class if its type argument is a primitive or reference type. Consider the following example: In the immutable |RRB-Vector| implementation, when elements from the front or back are removed, underlying arrays that store elements can be reused. Here, only starting and stopping indices of the resultant immutable vector are updated. However, if |Vector| is used to store references, reusing previous arrays can result in memory leaks (since the arrays keep a reference to the deleted object for the old vector, but create a reference path between the new vector and the deleted element). In this case, the ideal solution would be to change the behavior of the |Vector| class based on the type argument and only reuse the arrays for primitive types.

\paragraph{}
% motivation - if code is expected to be optimized but for some reason, optimization fails and there is no warning about that, define the behavior in that case
Various limitations can prevent the code from being fully optimized, and the Minibox plugin will try to recognize these and alert the user appropriately. However, it is possible that some unknown limitations exist and, in that case, code optimization can fail silently. To guard against this situation, run-time checks can be conducted to determine if the code has been optimized and define custom behavior to handle the situation.

\paragraph{}
% what is mbreflection
|MbReflection| exposes internal state by allowing reflecting on the type parameters of miniboxed classes. For example, given |class C[@miniboxed T]|, reflection can determine, at run-time, whether a type parameter is miniboxed, its instantiation, and the type used to store the value. By exposing internal state, |MbReflection| can help in solving the problems mentioned above. Usage is illustrated 	on the following examples:
\begin{lstlisting-nobreak}
scala> import MiniboxingReflection._
	import MiniboxingReflection._

scala> class C[@miniboxed T] {
    |   override def toString: String =
    |     s"C[T =${reifiedType[T]}, miniboxed into a ${storageType[T]}]"
    | }
	defined class C

scala> new C[Int]
	res4: C[Int] = C[T = Int, miniboxed into a Long]

scala> new C[Unit]
	res5: C[Unit] = C[T = Unit, miniboxed into a Long]

scala> new C[Float]
	res6: C[Float] = C[T = Float, miniboxed into a Double]
\end{lstlisting-nobreak}

Method |reifiedType[T]| gives the actual type of type parameter used while instantiating the class and |storageType[T]| gives the storage type used to store the value of miniboxed type parameter. The storage type of a miniboxed type parameter can be one of the following three types:
\begin{itemize}
	\item |Object| for instantiations with |AnyRef-based| types, erased generic types and value classes,
	\item |Long| for instantiations with |Unit|, |Boolean|, |Byte|, |Char|, |Short|, |Int| and |Long|,
	\item |Double| for instantiations with |Float| and |Double|.
\end{itemize}
It is still possible to instantiate the class in an erased context, leading to sub-optimal storage. The Miniboxing plugin returns a warning when this happens, which can be confirmed by reflection as well:

\begin{lstlisting-nobreak}
scala> def newC[T] = new C[T]
<console>:11: warning: The following code could benefit from miniboxing
     specialization if the type parameter T of method newC would be marked
     as "@miniboxed T" (it would be used to instantiate miniboxed type
     parameter T of class C)
            def newC[T] = new C[T]
                          ^
     newC: [T]=> C[T]

scala> newC[Int]
<console>:13: warning: The method newC would benefit from miniboxing
     type parameter T, since it is instantiated by a primitive type.
                   newC[Int]
                       ^
	res3: C[Int] = C[T = Object, miniboxed into a Object]
\end{lstlisting-nobreak}


Method |isMiniboxed[T]| determines whether the type parameter has been successfully miniboxed or not. A particular use case for this method arises when it is expected that a class is always miniboxed, and an assertion raised if it's not.

\begin{lstlisting-nobreak}
scala> class D[@miniboxed T] {
    |   assert(isMiniboxed[T], "Type parameter T of class D is not miniboxed!")
    | }
    define class D

scala> new D[String]
    java.lang.AssertionError: assertion failed: Type parameter T of class D is not miniboxed!
    at scala.Predef$.assert(Predef.scala:165)
    ... 34 elided
\end{lstlisting-nobreak}

\paragraph{}
Methods |reifiedType[T]| and |storageType[T]| are not partially evaluated and do incur a small overhead. However, |isMiniboxed[T]| is partially evaluated away by the compiler and does not incur any addition overhead. Given definition of method |foo|:

\begin{lstlisting-nobreak}
scala> def foo[@miniboxed T]: Unit = {
    |   if (isMiniboxed[T])
    |     println("foo[miniboxed]")
    |   else
    |     println("foo[reference]")
    | }
	foo: [T]=> Unit

scala> foo[Byte]
	foo[miniboxed]
\end{lstlisting-nobreak}

will be translated in the low-level bytecode:

\begin{lstlisting-nobreak}
def foo(): Unit = println("foo[reference]")
def foo_J(...): Unit = println("foo[miniboxed]")
def foo_D(...): Unit = println("foo[miniboxed]")
\end{lstlisting-nobreak}

which shows how the compiler partially evaluates the code and tries to minimize any run-time overhead.